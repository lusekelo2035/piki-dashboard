"""
Piki Weekly Business Intelligence Dashboard
============================================
Architecture:
  1. Global Filters (sidebar: city, business, date range, time period)
  2. Shared data prep ‚Äî one pass, all sections reuse filtered df
  3. Four tab sections selectable via pills/tabs:
       üìà Weekly Trends    ‚Äî orders, sales, KPI, failed & rejected orders
       ‚è∞ Delivery Times   ‚Äî stage breakdown, hourly, city charts, heatmap
       üö¥ Rider Attendance ‚Äî attendance pivot, deficiency alerts
       üì¶ Products         ‚Äî product mix, business rankings, geo area tool
  4. Every section has AI Insight + Q&A chat
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import FuncFormatter
from io import BytesIO
from math import radians, sin, cos, sqrt, atan2
import numpy as np
from datetime import datetime, timedelta
import io
import re
from collections import defaultdict
from rapidfuzz import fuzz, process
import folium
from folium.plugins import HeatMap, Draw
from streamlit_folium import st_folium
from shapely.geometry import Point, Polygon
import anthropic
import os

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# PIKI LOGO (embedded base64)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
PIKI_LOGO_B64 = "/9j/4AAQSkZJRgABAgAAAQABAAD/wAARCANIBbADACIAAREBAhEB/9sAQwAIBgYHBgUIBwcHCQkICgwUDQwLCwwZEhMPFB0aHx4dGhwcICQuJyAiLCMcHCg3KSwwMTQ0NB8nOT04MjwuMzQy/9sAQwEJCQkMCwwYDQ0YMiEcITIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIy/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMAAAERAhEAPwD3+iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAopN3tRmgBaKTdRuoAWim7qY08a/ekQfVqAJaKrG+tV63MI+rio21awXreQf99ik2luOzLtFZx17S1PN9AP+BUw+I9HHXUYB/wKlzx7lezn2NSisn/hJtG/6CVv/wB9UDxNox/5iMH/AH1Rzx7h7KfZmtRWWPEekMcDUID/AMCqRda05+l7Af8AgYo549w9nJdDQoqsuoWj/duYj9HFTLKjj5WU/Q1Sd9iLD6KbupQaAFopM0ZoAWikByaWgAooooAKKKKACiiigAooooAKKKTNAC0Umar3V/bWUZe5mSNR3Y4ovYFroizSE1yd78QNKtyVgElw3+yMD8zWJcfEe6ckW9lGg7F2yawniaUN5HZTwGJqfDB/kejUV5TJ481t+jQIPZP/AK9V28Z643/L3j6KKwePoo6Vk2Jfb7z17NFeP/8ACYa7/wA/zf8AfIqRPGmuof8Aj6DfVBR/aFLzH/YuJ8vvPXKB1ryyLx/rCEb1gkH+4R/WtW0+JAyBd2OB/ejbP6VccbRfUxnlWKh9m/oz0CisnS/Emm6sALa4XzO6Nw1aoORXTGSkrpnDOEoPlkrMWikpaokKKKKACkpaSgApM/WuJ8TeMbnStSFrZpEwAyxYZwaxf+Fg6t/zzt/++T/jXNPF0oS5W9TvpZbiKsFOK0Z6hn60Z+teX/8ACwdW/wCedv8A98n/ABo/4WDq3/PO3/75P+NR9eo9zT+yMV/L+KPUM/WjP1ry/wD4WDq3/PO3/wC+T/jR/wALB1b/AJ52/wD3yf8AGj69R7h/ZGK/l/FHqGaM15f/AMLB1b/nnb/98n/Gj/hYOrf887f/AL5P+NH16j3F/ZGK/l/E9QzSjrXmKfETUlPz20DD2yP61rad8Q4pp0ivLXydxxvVsgVccZRlomRPLMVBXcfyO5opkciyxrIhBVhkEU+uk4HoFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFBpM0ALRTc1n3+u6dpoJurqND/dzk/lSbS3GouTslc0qaetcXd/EayjJFrbSzejN8orHm+IuouT5NtBH/vZaueeLox0bOynl2JqaqH36HplGa8nk8c64/8Ay1iT/dSoD4x1w/8AL6R9FFZPH0ToWTYl9vvPX8ijNeQDxhrg/wCX0n/gIqVPG+uJ1nRv95KP7Qo+Y3kuJ8vvPWs0o6V5fB8Q9UjP72C3kHsCv9a27H4i2chC3ltJCT1ZfmFaxxlGTtcwqZZioK7jf0O2oqnZanaajCJbSdJV/wBk9Kt5roTT1RwtNOzFooopiCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKTNNeVUUsxCqOpJxQA+mk81gah4z0iwJXz/ADnH8MQz+tc3efEeZiRaWSqOzSt/QVjPEUofEzqpYKvW1hFnoeaK8ln8b63PnE6Rf7if41SfxLrMh+bUJvwOK53mFJbHbHJcS97L5ns+fej8a8U/t7Vs5/tCf/vqpE8Ta1H93UJfxwalZjT7Mp5JX6NHs+aUGvJoPHOtw43SxSj/AG0rYs/iOwwLyyyP70bf0rWOOoy62MKmU4qGyv6HoVFYWn+LtI1DaqXIjkP8EnBrbVwwypBB6EV0xnGWqZwTpyg7TVh1FJuozVEC0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVBdXC2tu8zkBUGTUx6VyXjvUha6P9nU4eY44qKk1CLk+hpRpurUUF1Mi4+I825hBYJwSMu/+FUJvH+ryf6tYI/8AgOa5QUteHLG1pdT62GV4WP2L/ebkvjHXZf8Al8Kf7qgVVk8Q6xL97Ubg/RsVm0Vm8RVe8mbxwWHjtBfcWH1G+f715cH/ALat/jUTXEzfemkP1cmmUVDnJ9TZUqa2ivuAsT1JP40lLRU3ZXKuwlFLRRcYnFGB7UtFIYlFLRRqIASpyCQfapUu7mM5S5mX/dkIqKiq5pLZkuEXujQi17VoP9XqFwPq+f51o2/jfW4CN1wsgHZ061z1FaRr1Y7SZjPB4ee8F9x3Ft8R5l4urFW943x/Ot6y8c6PdYV5GgY9pBgfnXlNFbxx9Vb6nFUyfDS+HQ92try3ul3wTxyKe6sDVivBre7ubR99vPJE3qpxXVaV4+vrYql+guI+m4DDV2UswhLSeh5lfJq0Nab5vzPT6KytK12w1iPdazAsOqHhhWoDXfGSkro8iUJQfLJWYtFFFMkKKKKACiiigAppp1Z+sXgsdMnn6FVOPrSbSV2NJt2Rz3ijxgNLJtLLa9z3bsn/ANevObu9ub6Uy3U7yuf7x4H4VHNM9zO80hy7nJNMrwcRiZ1ZNX0PscFgKeHgna8u4lLRRXKegFFFFABRRRQAUlLRQAsckkMgkico68qwOMGvWfB+tvq+mYmOZovlY+teS16J8OYGjsrmUj5Xbiu3AzkqqitmeVm9KEsO5vdbHcjrS00dadXuHyQUUUUAFV7y4FraSzsRhFJqxXIePNS+y6V9mRsSTH9KipNQi5M1o03VqKC6nm9/dG91Ce4Y53uSKgpBS183J8zbZ93CChFRXQKKKKkoKKKKACiiigBKMFsKASSeKWtTw5YHUdbgiHIRg7fSmlzOyJlNQi5PZHrWiIyaNaK/3hGM1oUyNAiKgGABgU8V9NBcsUj4KpLmm5LqwoooqiAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAA1FLIsMbSOwVVGST2qQ9K5Dx5qT2mlrBE215Tg/SoqTUIuTNKNJ1ZqC6mJ4j8a3FxK9rpzGKIHBlB5b6Vxru0jl3ZmY9WY5Jpo6UtfP1a86ru3ofaYbCUsPHlgte/USloorE6gooooAKKKKACkpaKALml6ncaVeJPbyFQD8y54Ir2bTrtb6whul6SKDXhmN3yjqeK9p8NxNBoFpG3URivSy6cuZx6Hg53ShyRqdbmsKKKK9c+bCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigApCcCg9K47xj4mOmx/Y7Vv8ASJByw/hFRUqRpxcpbGlGjOtNQgtWXdf8X2mjgxR4nuf7inhfrXnOqeINR1ZybidhHniJDhRWaztI5d2LMTkk96SvEr4ydTRaI+rwmWUqCvJXkJS0UVyHphRRSUALRSc+hooAWiiigBK2dJ8T6lpLjy5jJDnmKQ5H59qx6KuE5Qd4uxlUowqrlmk0evaH4pstaQKreVP3iY/yreFeCxTSW8yywuUdTkMK9V8JeIxrFr5UxAuo+G/2h616+FxntPdnufNZhlboL2lLWP5HT0UUV3njhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUANNeSeM9R+3a46I2YohtH1r0zWb0WGlzzk4KqcfWvFJJTPM8zfecljXnZhUtBQ7nt5LQ5qrqvZfmNooorxz6cKKKKACiiigAooooAKKKTIoAWikzRketAC0UZooAKKKKACiiigAooooAKTFLRQA+CeW2mWaCRo5F6Mpr0Pwz42W5K2molUm6LJ2b615zRk5BBII71tRxEqTujkxWDpYmNpb9z3wNkAjoadXDeCfErXSjTrtsyqPkYnqPSu4HSveo1Y1Y80T4/EYeeHqOExaKKK1MAooooAKwfFsMk3h+4WMFjjPHpW9TJEWRGRgCpGCDUzV4tF058klLseBilru9e8ByGV7nTCpDHJhPH5GuMutPvLJylzbSxkf3lOK+eq0J0naSPtsPi6VeKcH8ivRRketFYnSFFFFABRRRmgBKWrFtp17dttt7WaQn+6prptN8AX9yyteutvH3Ucsa0hSnP4Vcxq16VJXqSsc1p+n3Gp3iW1uhZmOD7CvZNG0xNK0yG1j/hHJ9TTNK0Sy0eDy7WIA93PVq0x0r18JhfZe9Lc+YzHMfrPuQ+EMUtFFdx5QUUUGgBpbAya8j8Z6l9v1x0BzHFwpr0zXL4afpM9weqqcV4pJIZpXkYkljnmvOzCraKh3PbyWhzVHVfQSiiivHPpwooooAKKKKACiiigBK9D+Hmm7YZr515Y4Q+1efxRtNMkSjJYgYr2vRbJdP0u3t1/hQZrtwFPnqXfQ8rOK/s6HKt5Ghiloor3D5IKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAQ9K8++I0Mha3mx8gGM+9ehGqOpadb6pZvbXCBlbv6H1rGvT9pTcF1OjCV1QrRqPoeHUtdPq3gfUbF2e1X7TB22/eH4VzcsMsLFZYpIyOzKRXz86c4O0kfaUq9OtG9N3GUUmfelqDYKKKKACiigAscKCT6AUAFJmtGy0HVL8gW9nKQf4mXaPzrrdI+H2HWTU5twHPlR/1Na06FSp8KOavi6NBXnIwfC3h+bV79JXQrbRtlm9TXrkaCNFQdAMCo7W1hs4VhgiWONeAFGKnr28Nh1Rj5nyuPxrxU9NEtgooorpOAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAIbqbyLWWX+4pNeH6hdvf381y5JLsTXtOrIX0q5Veuw14bggkHsTXmZlJ2S6Hv5FCLc5PfQBS0UV5J9GFHSikoA6Xw14Ul1sied2itQeo6t9K9AsvCukWKAJZxuw/icbjVHwVf29zokUMZUSRcMvcV1Fe3hMPTUFK12fJ5jja7qyp3sl0Kh02zK7TbQ49NgrNv8AwjpF8h3WqxuejR/KRW7SHpXU6VNqzR58cRWg7xk/vPH/ABF4am0KUMGMtsx+V8cj61hCvS/H9/bppP2MkGaQ5AzyK80HSvExdKNOpaJ9ZluIqV6HNU3/ADCiiiuU9AK0NCvn0/WbeZWIXdhh61n0+3RpLqJF+8XH86cW000ROKlFxezPd433xq/94A1IKr2oK2sIPUIP5VOK+mi20mz4KaSk0haKKKokKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKDTHkEaMzdFGTQBwvxD1LbDDYIcFjuOK89ArU8RX51HW55c5QNhazK+fxdTnqtn2eXUPY4dJ7vUKKKK5jvCiiigAooooAKSloCliFH3icCgDrvBGhQalJNc3UIliX5QrdM16BHo2mxjC2UA/wCACqvhfTxp+iQR7cOw3P8AWtnFe7haEY01danx+YYypUryUZNJaFP+zLH/AJ9IP++BTH0fTpBhrKAj/cFX8UYrp9nDscPtqn8z+8wp/CGiXAO6yVSe6Eg1gaj8O4iC2n3LKeyScj867zFBXNZSwtKe8Top5hiae0n8zw3UNMu9LuDDdxFG7HsfpVOvatd0iHVtOkhkUF9pKNjoa8YmiME8kJ6oxWvIxWG9i9Nj6XL8csVF3VpIbRRRXKeiFFFFABRRRQAUUUUATWd09leRXEZ+ZGBFe22Fyt3Ywzqc7lBP1rws1614JmM3hyEsckcV6OXTam49DxM7pJ0lUW6OkpaQUtewfMBRRRQAUUVG8yR/fdVz6nFADzTJIklUq6KwPYjNN+0w/wDPVP8AvoUfaYf+eqf99Ck7PcautjPn8O6Tc/62whY+u3H8qpv4L0N/+XPb/usRW59oh/56p/30KPtEP/PVP++hWToUnvFG8cXXj8M395zx8B6GT/qZf+/hoHgTQx/ywkP1kNdD9oh/56p/30KPtEP/AD1T/voVP1aj/Ki/r+K/nZix+DNCT/lyVv8AeYmrsOhaXbf6qxgX/gOau/aIT/y1T/voUoliPSRT+NUqNJbRREsVXlvN/eOSNY1CoiqPQCn00OD0INLnmtkrHO23uLRRRQAUUUUAFIelLTJXEcbOxwFGTQBwfxD1LCQ2MbYbO5h6iuAFaXiC+bUdZuJicqGKqfas2vn8VU9pVbPtMvoexw8V1eoUUUVzHcFFFFABRRRQAUUUhOBmgDo/BWnfbtdWUjKQfMa9aUAVyfgTTTaaQZ3XEkpzn2rrRXuYGnyU7vqfI5vX9riLLZaC0UUV2nlhRSE4pN1ADqKjaeNDhpEB9CaT7TD/AM9U/wC+hQBLRUX2mH/nqn/fQo+0w/8APVP++hQBLRUX2mH/AJ6p/wB9Cj7TD/z1T/voUAS0VF9ph/56p/30KPtMP/PVP++hQBLRUX2mH/nqn/fQoFzCTxKn/fVAEtFNDhumDS0ALRRRQAUUUUAFFITgVGbiJSQ0iAjsTQBJVeezt7gYmhjkH+0oNP8AtMP/AD1T/voUfaIf+eqf99Ck0mtRpuLujLl8LaLMSX0+LPqOKqt4H0N+fszL/uuRW99oh/56p/30KPtEP/PVP++hWToUnvFHRHGYiO0395zv/CB6H/zxl/7+Gnr4G0NT/wAe7n6yGt/7RD/z1T/voUfaIf8Anqn/AH0KX1aj/Ki/r+Kf22Y8fhHQ4zxYRk/7RJrQh0qxt8eTaQpjuFFWPtEJ/wCWqf8AfQpwljPR1P41UaNOOyRlPE1pfFNv5jwoHQUtNBz0p1amG4UUUUAFFFITgUALTScZzwBTJp44ImkkYKijJJ7V5p4m8ZTX8j2tgxjt84Ljq/8A9asq1aNKN5HRhsLUxE+WCPRze2oODcRZH+2KPttr/wA/MP8A32K8Ky394/nRlvU1wf2kv5T2P7Cf8/4Huv221/5+Yf8AvsUfbbX/AJ+Yf++xXhWW9TRlvU0f2kv5fxD+wn/z8/D/AIJ7r9ttf+fmH/vsUfbbX/n5h/77FeFZb1NGW9TR/aS/l/EP7Cf/AD8/D/gnuv221/5+Yf8AvsUfbbX/AJ+Yf++xXhWW9TRlvU0f2kv5fxD+wn/z8/D/AIJ7r9ttf+fmH/vsUfbbX/n5h/77FeFZb1NGW9TR/aS/l/EP7Cf/AD8/D/gnuv221/5+Yf8AvsUfbbX/AJ+Yv++xXhWW9TRlvU0f2kv5fxD+wn/z8/D/AIJ7st3bMcLPGT7MKlDA9DkV4KGdejsPocV0nhPXNQh1eC1ErywyNhlY5xV08wjKVmjKtktSEXKMr2PWB0paRelLXoniBRRRQA2RQ8ZVhkEYIrx7xTpEmlatJ8v7mQ7kI6D2r2M9KzdY0i31eya3uF/3W7qa5sVQ9rCy3R3ZfjPq1Xmez3PExRWprOgXmizlZULQk/LIBwfrWVmvBlFwdpH2FOpGpHmg7oWiiipNCa1vLmxnE1tM0Ug7g11dl8Q76FQt1bxzf7QODXHUYranXqU/hZzV8JRr/wASJ6AfiRFjjT5M/wC+Kzb74gahcIUtoY7cH+L7xrkaMVrLG1npc5o5VhYu/Lf5klxcTXUzTTyNJI3JZjUdJilrlbbd2ehGKikkrIKKKTNIoK6bwXor6jqq3TqfIgOcnoTVTQfDV5rUysEMdsPvSEdfpXq+nadb6ZaJbW6BUUfnXbhMM6kuZ7I8rMsfGhBwjrJ/gWwuBilFLRXuHyQUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAIawvFmo/2fokzKf3jjao9a3TXmfxA1IT38Vkh4iGTj1rDE1PZ0mzrwND21eMOhxxOST680UUV87e+59stFYKKKKBhRRRQAUUUUAFa3hrT/7S1uGIg7FO4n6Vk9q9E+HuneXayXzjPmHC57Vth6ftKiicuNrexoSmdvGoVQo6AYp9IOtLX0Z8P5sKKKKACiiigBr/AHT9K8R1og6zdFem817NqVytpp887HhEJrw+4k866mlz99i1ebmT91I93I4vnnLyI6KKK8g+lYUUUUAFFFFABRRRQAh716r4DUjw5GT3NeVdePWvZPC9obPQbaMjHy5/Ou7ARftTyM6lbDW7s2hS0gpa9s+UCiikNAATivKPG2ptd60YY3by4eAQe9ekateLYaZPcH+FeK8UmlM9xJMSSXYtzXn5hU5Yci6ns5Lh1Oq6ktl+Ynmyf89G/M0ebJ/z0f8AM02ivI5n3PpuSPYd5sn/AD0f8zR5sn/PR/zNNoo5n3HyR7DvNk/56P8AmaPNk/56P+ZptFHM+4ckew7zZP8Ano//AH0aUTSjpLIP+BGmUUc0u4uSHY09P8Q6np06vHdSMgPKO2VIr17S74ajYRXIBG8civDlUs6KBklgK9v0a2+yaXbw+iivSy+pOUmm7o8LOqNKMIyirSZfooor1T50KKKKAErA8Xal/Z+hzMD87/KB9a3jXmXj7UhcalHaI3ywj5h61hians6bZ14Gj7avGBx49+tLRRXzp9utNEFFFFABRRRQAUUUUAFWNPtTe38NuBnewBx6VXrsPh/p3n6hJesPljG0Z9a0pQ55qKMcRVVGk5voj0a1t1tbWOFRwi4qelor6SKsrHwkpOUnJ9QoopppiFPSsDxH4jg0S2IBDXLD5EH8zUXiTxRBo0JijIe7YfKvp7mvLLu7nvrl7i4cvIx5JrixWLVJcsdz1Mvy6WIfPPSP5jrq/uby5a4nmcuxz948VD5sn/PR/wDvo02ivGc5N3bPqo0oRVkh3myf89H/ADNHmyf89H/M02ilzPuVyR7DvNk/56P+Zo82T/no/wCZptFHM+4ckew7zZP+ej/maPNk/wCej/mabRRzPuHJHsO82T/no3/fRo82Qf8ALR/++jTaSlzPuHs4vobGj6/f6bexFJ5HiLAGNmyDXsUL+ZEjn+IA15x4S8Jy3MyX96hWFeUQ/wAXvXpIG0ACvYwCqcrctj5fOJUXUUaaV1vYfRRRXoHjhRRSGgCC8nW2tJJnOAqk5rxK+vpby/muGdgXYnG6vRvHmpfZdJFsp+aY4rzCvKzCq7qCZ9FkuHTjKrJb6DvNk/56N/30aPNk/wCejf8AfRptFebzPue9yR7DvNk/56N/30aPNk/56N/30abRRzMOSPYd5sn/AD0f8zR5sn/PR/zNNoo5n3Dkj2HebJ/z0f8A76NOW5nQ5SeRT6hzUdBo5n3F7OHY6nwz4pv7bUI7e5meeCQ4+c5I/GvVFO5QfWvGPDFqbvxBbx44B3H8K9nUYUD0r18BOcovmZ8znNKlTqLkVmxaKKK9A8YKa5CoSTwKCea5Lxrr39n2f2OFh58w59hUTmoR5maUaUqs1CO7Oe8ZeJmvp2sLVyIEOHYfxGuQFHJ5OSe5NWrS0S6Yq13DAf8AprkA18/VqyrTufaYahTwtJRXzK1FdBF4SknGYdUsH+klTf8ACC6m33JrV/pJR9Xq/wAofXcOtHNHM0V0jeBNbA+WKJvpIKgfwZrqdbMH6SA0nQqL7L+4pYug9pr7zCorWk8Ma1H10+U/7vNVpNG1KL79hOP+AGocJLoaKrB7SX3lKipGtrhD80Eq/VDUR+U88fWlYtO+wtFJmikMWikqzYafdalcrb2sZdyfwHuaaV3ZCbSV2QojyuqRqWdjgAd69L8IeFv7MT7ZdgG5ccL/AHRVvw54UttHRZpQJLsjlz2+ldJkKCTwK9XC4LlfPU3PnMxzTnTpUdurFXpTZJEiQvIwRR1JOAK4fxX8TNL0EvbWhF5egEbVPyofc149r3jDWvEUjG8umEJ6Qxnag/xr0zwT3LUviJ4Z0xzHJqSSSD+GEb/5cVHp/wASfDOoyiNdQELngCZSv6185gYpaAPrSGaOeMSRSK6HoynIqSvl3RvE+saBKH0+8kjUHmNjlD+Br1fwz8WrG/KW2sRi0nPAlH+rJ/pQB6JcW0N1C0U0ayIeoYVxWteAEfdNpbbG6+Ux4P0ruYZ4riJZYZFkjYZVlOQRUh6VjVoQqq0kdGHxVXDu9N/I8HurO4sZzDcxNG47EVDXtup6PZ6tAYrqEN6N3H0Neca74NvNLLS2wNxb+o+8o968mvgp09Y6o+lwea0q/uz92RzNFJ3pa4j1QooooAKKACxCqCSegHeus0HwPdX5We/zBAedg+8f8KunTlUdooyq1qdGPNUdkc5Yadd6lcCG1haRievYfU132jeAra2Czai3ny9dg4Uf411Wn6ba6bCIbWJUUenU1dr1qGAjHWerPnMXnFSpeNHRd+pFFEkMYjiRUReAAMAVJS0V3pJaI8Ztt3YUUUUxBRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRSUAQXlwtrayTv0RSa8S1C6a91Ge4Y53OSD7V6P471P7JpHkI37yU4x7V5cOBxXk5jU1UD6PJKFoyqv0FooorzD3wooooAKKKKACiikNAEkETXFxHCgyzsAK9s0iyWx0yCBRjaoz9a808E6d9t1sSuPkhG7PvXrI6V6uXU95s+dzyvrGivUAKWiivUPnwooooAKQmjNct4l8W2+lRPb27CS7IwAOQv1qZzjBc0i6dOdWShBXZm+PdcWOAabA2Xf7+D0Hoa88AxUk88t1O80zl5HOSTTK+fxFb20+bofZ4HCrDUlHr1CiiisDsCiiigAooooAKKKQnFAGholidR1eCAKSu7Lewr2uKIRRIg6KoArjfAmhm1tTfzpiSUYX6V2w6V7WApcsOd9T5XOMSqlVU47RExS0UV3njhSGlpsjBELE8AZoA4b4hal5dtFYxth3+Zh7V54OlaviXUG1HXJpCcqh2qfasqvn8XU9pVbPs8toexw6T3eoUUUVzHeFFFFABRRRQAUUUUAbXhTTzqGuwjGUjO569iUBQAOg4rjPh/pvkWD3ki4kkOB9K7QV7eAp8tPmfU+Tziv7SvyLaItFFFdx5IUUUUAVr25S0tJZ3OFRSa8Rvrl7y/muHOWZjz7V6N491L7NpQtkPzTHBHtXmIGK8nMal2oI+jyShaMqz66C0UUV5h74UUUUAFFFFABRRRQAYyQo6ngV6/4S07+z9DhVlxI43NXmfh+wOo61bwlcpuBb2r2eNBGioOijFell1O8nNnhZ3X5YRpLqSDpSE4oHSobm5htYGmnkVEUZJY16580vIl3CuN8T+M47IPaWDCSc8M4PCVjeI/G0l5vtdOJjh6NL3b6VxuSSSSST1zXm4nGpe5T3PdwGUuTVSurLsPmmkuJmllcvIxyWPem4pKWvJbbd2fRxSS5UFFFFIoKKKKACiiigAopK39E8J3+sMHK+Rb/wB9hyfoKqEXN2SM6lSNOPNN2RiwQTXMyxQRtJI3RVFd/wCG/BAgZLvUwGkHKw9l+tdJo/h+x0aILbxAyfxSNyxrW7V6uHwPL71Q+exucOd4UNF3GqgUAKAAOgFOxRS16R4T11YCiiigAppODTqzdbvV0/S7icnDBTt+tJuyuOKcnZHmfjLUft+uOqNmOIbQPeueAp8kjTSvK/3nO402vm60/aTcj7rDUVRpRproFFFFZm4UUUUAFFFFABQaKVI2lkWNBlmIAFAHd/DzTj++vnHB4Q16COlZmhWKafpFvCox8oJ+taY6V9Dhafs6SR8VmFf22IlLpsLRRSGug4ive3KWdtJPIQFQZ5rxq9uZdc1eWZ5Y49zHb5rYAH1rsfH2tbIhpkLfM/MnsK89rycfWvJU1t1Po8mwrjF1nu9jcj8K38v+rmsm+lwKlPgvWcZEUTf7soNc+CVOQSD7VMl5dRnKXMy/RzXEnR6p/wBfI9VrE/ZlH7n/AJmq/g/XE/5cy3+6wNN/sHxDB92zu1A/uH/A1Wj17VovuahcL/wOrKeLNcj/AOX+Rv8AeANWnRWzaMpLFPeMX9/+QD/hJLX/AKCC/wDfRpw1/wAQwcm5ulx/fT/EVMvjfXFH/HxGfrGDT/8AhONVP30t3+sYq1OPSo/u/wCCZOlN/FRi/n/wCNfGuuRnBuVP+8gqZfH2tD7xgYe8dRt4vmkGJdOsnz6x1n3eqw3Skf2ZaRMf4owQabrTW1QSwtKTtKhb5o2h8QNQIxJaWz/Vaa3jUyf63RrJ/qv/ANauUpayeJqvdnQsBh18Kt83/mbs3iCxn+/oFpn1VyKyLqWGaXdDB5C/3Q5YVBXVeG/B82qMtzeAxWvUDu9SnOtLlS/AqUaWGjzybt5tszNE8PXetzgRKUgB+aUjivVNH0O00e1EVug3fxORy1XLW0gs4Fht41SNegFYfivxjYeFbMvOwe5Yfu4VPLH39BXr4bCRpK8tWfN47Mp4h8sdI/n6mtqWq2Wj2jXV9cJDEo6sevsK8S8X/E2+1wyWmmFrWx6FgcO/+ArmfEXibUfE181xeyny8/JCD8qCseuw8wOSSSck9SaKKKACiiigAo60UUAdJ4Z8bat4ZmAhlM1rkboJDkY9vSvcvDPjLS/E9sGtpQlwB88Dn5l/xr5pqazvLjT7pLq0meGZDkMpxQB9ZDmkZQwwcEe9eYeEvixa3aR2muHyLjgCcD5G+vpXpdvcw3cKzW8qSxtyGQ5BoA5rXvBVpqW6e2xBcew+VvrXnOpaVeaTOYruFk9G/hP417gRxVW8sbe/gaG5hWRCMYYVxV8FCprHRnq4PNalC0Z+9H8TwvNaWlaJfazMEtojs/ikI+UV3Mfw9sU1AzNM7W+ciH/69dbbWsFpCsUESxxr0VRXHSwE2/f0R6eIzmlGP7rV/kYOheELHSQJHAnuepdh0PtXRhcdKWlr1adKNNWij52viKleXNUdxAKWiitDEKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigApp4HNOrO1m+XTtKnuHPRTj60m0ldjSbdkeZ+NNR+3660an5IRtHvXPU6SRppnlc5ZiTmm183Wn7SbkfdYaiqNKNNdAooorM3CiiigAooooAKQnAzS0UAeoeBrKOz0fzWZd8x3cnnFdYGB6YrwZJ5ov8AVyyJ/usRVhdU1BPu31yv0lNenRx0KcFHlPAxWU1a9WVTnWp7jmgsB1IFeIf2xqmP+Qjdf9/TTH1K/k+/e3DfWQ1r/aUOxzrI638y/E9rmvrW3XM1xGg/2mArCv8AxtpFmCI5zcSD+GMf1ryhndzl3Zj6k5puKynmL+zE6KeRRX8Sd/Q6fVvG+o6gGit8W0J4+X7xH1rmSSzFmJJPJJOSaKK4aladR3mz16GFpUFamrBRRRWR0BRRRQAUUUUAFFFJmgArpPCfhyTV7sTzKRaxkEk/xGm+G/C0+szrLMrR2gOSxH3vpXqtpaQ2VukECBI0GAAK7cLhXUfNLY8nMcxjQXs4P3vyJI0WNFRAAoGABUlJilr20raI+Ubu7sKKKKYhKxPFOpDTtDmkB+ZhtA+tbR615t8QdR828jskbiPlh61jiKihTcjqwdH21eMOhxeSSSTkmloor5y9z7jToFFFFABRRRQAUUUUAFS2tu11dxQKMmRgvFRV1XgTTfterG5YZSEenerpw55qJlXqqlTlN9Eekadaiz0+C3XgIgFXKQDilr6WMeVJI+EnJzk5PqFFFFMkKaxA5NKazNdvl0/SZ5ycHaQPrSbsrjinJpI8z8Y6j9v12QKx2RfJjtWDSyO0srSOcsxyTSV83Vn7Sbl3PusNRVGlGC6BRRRWZuFFFFABRRRQAUlLSxxtNMkSfedsCgDv/h5pwWKa/Yff+Vc9q7zNYdpNZeHdDgS5lSLagLA9Scelchrnju4u90OnAwRdPMP3j9PSvcpyhhqK5j5LEU6uOxMnTWm3kddrfiiw0ZCrOJJ+0a9fxrzPWNfvdamLTvtiz8sS8AVmuzyOXdiznqxOSaSvPxGMlV0WiPZweWU8P70tZBRRRXGeoFFFFABRRRQAUlLU1rZ3N9MIraB5XPZR0oE3bcgq9pukX2rTCO0gL88seFH412OifD8ZWbVXyevkr/U13NtZwWcIit4kjQdAoxXdQwM56y0R5GKzelSvGn7z/A5fQ/A9pp+2e8/0i464P3V/CusRQgCqAAOwp2KWvWp0YU1aKPnK+Kq15c1RhRRRWpgFFFFABRRSHpQAZrgfiHqX7uKwQ/e+Y4ru5HCRs56KMmvF9fvzqOs3E+cpuwvtXHjavJTt3PTymh7XEJvZambRRRXhH14UUUUAFFFFABRRRQAVveD9O+367GSPkh+fNYBOK9P8A6Z9m0s3Lj55jkH2rowtPnqpHHj63scPKXXY60LgY9KeKTFLX0J8SFQXUy29tJM3RFJqc1T1O3a706eBDhnQgUntoOKTaueL6ndvfalPcO27cxx9Kq1ZvNPu7Gd4p7eRNp6lTg/jVXNfNTbcm5H3tKMYwSjsLRRRUGgUUUUAFFFFABRRmkzQAtKiPLIqRqWZjgKOSams7K41C5W3tomd2PYdPrXqPhzwnbaPGJpQJbojliPu/St6GHlVemxyYvGU8NG89+iMjwz4J8vZeamoL9Vi7D613KqEUKoAAp2QoySMCvKfiD8R/szSaTo8n777ss6n7vsPevco0IUo2ifI4rF1MTLmm/ka/jb4kWuhI9lpxW4vyME/wx/X3rw+/v7rVLt7u9maWZzksx6fSoGZncu7FnY5LMckmkrY5gooooAK09F8Pan4guRBp1s0n95zwq/jSeH9LGta7bWJcIsjDcfbPIr6X0nSbPRrCK0soUjjQY4GCfc0AedaL8GrSNFk1i8kmfvFD8q/n1rqYfhv4WhTaNLVvd2JNdWBiloA4XUPhP4avEPkwy2snZonP8jXmniX4Z6xoZaa2Q31oOd8Y+YD3FfQtIVzQB8jsCrFWBVgcEEYxRX0nr/gPQvEKs1xarFcH/lvCArfj615Zr3wm1jTS8umsL+EfwqNrgfTvQB58a0dM13VNHkD6fezQH0VuD+FVLi2uLOYxXUEkMg/hkUg1FQB6FYfGDX7YBbuC2ulH8RUq36cVvQfGuAgCfR5FPqkuf6V4/RQB7UPjRpeP+QddZ+oqtcfGuAf8e+kSN7vKBXj1FAHplx8aNVY/wCj6ZaJ6b2Y/wBazZ/i34nlz5bW0Of7sef51wtKoZzhFZj6KM0AdVL8SfFk33tT2/7kYFUpfG3iWX72sXQ/3WxWfFouqzLui027dfVYW/wqK406+tf+PiyuIh/txEUAaH/CW+Iv+g1e/wDf010vgbxf4guPFdlZzajNcQSth1kO7iuAzXr/AMKfCE0BOt30ZTcMQow5+tAHrQpaKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKQ0ALXBfELUtsMVjG33jlx7V3MjiNGZjgAZNeMeIr86jrk8p6Kdg+lceNq8lLzZ6WVUPa4hPojLFLRRXhH2AUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFSQW81zII4Inkc9lGa6rSfAN9dFZL9vs0R/hHLH/CrhTnN2irmVWvToq9SSRykUMtxKscMbO7cBVGTXdeH/AZylzquPVYQf511ulaFYaRHttYQGxy55Y1qCvUoYBRfNU18jwMXnMpJwoaLuRRRRwxqkaBVUYAA4FSClor0UklZHhNtu7CiiimIKKKKAILqdbe2kmc4CKTXiWp3j3+pz3DnJZjj6V6T451L7HoxgU/NP8v4V5WOABXk5jV1UEfRZJQspVn6IWiiivMPoAooooAKKKKACiikoADXrXgzThY6JGzLiWX5mrzTRbI6jq0FvglWbn2r2uKMRwpGOigCvRy+nebm+h4edV+WmqS6ktFA6UV7B8yFFFFACGuA+IepfLDYIchuXFd7K4jjZ2OAozXiuvX51HWbi4zxuKgfSuPG1eSlZbs9PKaHtcQm9o6mdRQKK8I+vCiiigAooooAKKKKACpLed7WdZo8eYhypIzg1HRTTsJq+jJ7y9ub+Yy3UzSOf7x6fSq9LRRJuTuxRhGEeWKsgooopFBRRRQAUUGp7Sxur6URWsDyueyimk3sJtLVkFSW9tPdzCK3iaVz2UZrtdI+H0j7ZNTl2Dr5UZ5/E12+n6XZ6ZGIrSBY19QOT+NdlHA1J6y0R5eJzajR0h7z8tvvOG0f4fyy7ZdTk8tP+eSHn8TXc2GmWemwiO1gSNR6Dk/jV6ivUo4anS2Wp8/icfWxD952XZbDQOadRRXQcQUUUUAFFFFABRRRQAUh6UtIelAGB4u1H+z9DlKtiRxtWvIc5yT1JzXX+P8AUvtGox2an5Yhnj1rkB0rxMdV5qnKuh9Zk9D2dDne8gooorhPWCiiigAooooAKKKKAJ7K2e8voYEGSzDivbrK2W0tIoEGFRcV5x4B077Rqb3jLxCMKfXNenivXy6laLm+p81ndfmmqS6C0UUV6R4QGm4p1FAETwxyqVkjVgeoIzWTc+FtFuiTJYRhj3XI/lW3RUSpwl8SNIVqkPgk0cnJ4A0aQ5UTJ7LJVZ/hzp5+5dTr9cGu1orF4Si/snTHMcVHaZwTfDaH+HUJB9UFRt8Nj/DqH5pXoGRTJp4bdC80qRoOrOcCp+o0Oxos2xf834I8/Pw3m7agn4pSf8K3uP8An/j/AO+DW5qPxC8MaaWWXVI3cfwwguf04rnLv4zaPHxa2V1P7kBP50vqFHsX/bGK7r7i0nw2Of3moY/3UrQtfh7pkRBnklmI7ZwP0rkJvjXJk+To647b5P8ACoP+F16hn/kEW2P+ujVUcFRXQznmmKl9q3oetWWl2WmoEtLaOIew5P41cwK8gi+Ncuf32jqf9yT/ABrVtPjNo8pH2qyuYPcAP/KumMVFWSOGc5Td5O7Nr4jarf6X4Ymawjcs42tIozsFfO5YuSzMSxOSTX0nYeOvDGsL5cepQ7m4Mcw2/wA+Kq6l8O/C+tgzi1ETvz5ls23P9KZJ870V6/e/BSI5Nhq0g/2ZkBH6Vg3Xwf8AEUJPkS2s4/39v86APPqK6m4+HHiu3OP7KeQesbqf61mz+Fdfts+dpF2uPSMn+VAGZBPLbTpPA7RyocqynkGu+0z4v65ZRLHdwQXgUY3H5GP1xXDyabfxf6yyuU/3omH9KrsjocMjL9RigD12D42RYH2jR5Pfy5Af51pW/wAZtCkP760vIfqob+Rrw7NGaAPoS3+KnhacgfbJI/8ArpERWtbeNPDt4wWHV7ViexfBr5lpCAeooA+sob22ueYbmKTP9xwanwK+SoppYG3QyvGfVGI/lW7p3jjxHpePs+pyso/gm+cfrQB9EanoemavEY7+yhnU/wB9efz61x958IfDlwzNAbm3J6BJMqPwNQ+BPiQ/iG7/ALN1KJI7wjKPGPlf/CvRhQB5TJ8FLYnMesTL7NEDUY+Cceedaf8A79D/ABr1uigDyqP4KWanMurzuPQRgVoQfB3w/H/rpbuU/wDXTAr0WjIoA5K0+G3hS1wRpSSMOjSOx/rW7a6HpVlj7Np1tFjoVjGasXN/aWUZe6uYoVHeRwK5fUPiZ4WsCR/aHnsOCsKFqAOuCKOigfhTJreGeMpLEjq3BDDNeZ3Pxp01CRa6bcyjsWIWs2X413GT5Wjx4/25DQB17fDPQG18ap5GFHP2cfcz612SRpGgRFCqBgADgV4yPjXqHfSLbHs7Vah+Nh/5b6OT/wBc5f8AGgD16ivObP4xaDMQLqC5tz6lNw/Sup03xj4f1bH2TVIHY/ws20/kaAN2ikDKRkEEeopc0AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABSGlpDQBheLNQGn6HM+cM42r9TXj/ACeSck9TXY/EDUvPv47NGykY+Ye9cdXiY+pzVOXsfV5PQ9nQ53vIKKKK4T1wooooAKKKKACiiigAorrPCPhm21mGWe8VtinauDjmt+T4d6YxJSe4X23Aj+VdMMJVnHmitDgrZlh6NR05vVHmlFehP8N4D/q7+QfVQagPw2f+HUR+MdDwddfZEs0wj+2cJRXcH4bz9r+P/vg0f8K3uP8An/j/AO+TS+q1v5S/7Rwv86OHoruR8N5u+oJ+CVIvw25+bUc/SOn9UrP7InmWEX2zgqTNekR/DiyH+su52+mBV6DwFokWN8Ukp/2nP9KtYGs+hlLN8Ktnf5HlOasQWV3dHEFtLIf9lCa9ht/DukW2PK0+EEdCRk/rWisMcYwiKo9hito5bL7UjkqZ5BfBBs8qsvBGsXeDJGtuh7yHn8q6XTvh5YwkNeTvcEfwgbRXZ4pR1rrp4GlHfU8+tm+IqaR91eRVs9Ms7BAlrbxxD/ZXmrO2nUV1RjGKtFHmznKbvJ3YgFLRRVEhRRRQAUUUUAFITig1Q1e8Wx0ye4Y4wvB96TdlcaTbsjzXxtqX27W2iVvkgyuPeuap80zTzyTPyzsSabXzlafPUcj7nC0fY0Yw7BRRRWR0BRRRQAUUUUAFJS0KhkdY1+8xwPrQB3Xw703c81+44+6uR3r0PFZXh2wXTtHghAwxXLfWtavoMLT5KSR8XmNf22Ib6LQKKKK6ThCkzzS0lAHP+MNSFhoUoBxJJ8q815Dknk9Tya67x7qX2jU0tEbMcQyfrXJV4mPq81Sy6H1mT0PZ0OZ7sKKKK4T1gooooAKKKKACiiigAorofC/h5dcNx5uVRV+Rge9ZOp6dPpV89tOuCp4PYir9nLk57aGKr03UdK+qKlFFFQbBRRRQAUUUUABrb8P+JJ9DmxtElux+Ze49waxKSqhJwfMjOrSjVg4SV0z2/TNVtdVtVntpAwPUZ5FXh1rxDS9Wu9IuhPayEc/MnZhXq+geILXW7cNG22ZR86HqDXt4bFxq6PRnyePy6WGfNHWJtUUUV2HmhRRRQAUUUUAFFFFABRRRQAmar3t0tpZyzt0RSasVyHjzUja6ULaNsSSnp7VFSahFyfQ1oU3VqRprqecX1y17fzXBYne5I+lQUgGBilr5qUnJts+7hFQioroFFFFIoKKKKACiiigApCTxSmtLQLBtR1q3hAyocF/pTSu7ClJRXNLZHpnhHTf7P0OIMPncbifrW+BTYkWOJUUYCjAp9fSUockFE+ExFV1aspvqFFFFaGIUUUUAFFFBOBmgBCcVla14k0vw/bmbULpI+OEzlm+grjPG/wATYdIZ9P0krNe9Gk6rH/ia8Xvb+71O6a5vZ3mmY5LMf5UAej698Yry4ZotFthbx9BNL8zH6DoK8/1HW9U1aQvf39xOT2dzj8ulUKKAExS0VLb2tzduEt4JJWPQIhNAEVFb0HgrxLcDKaPcjP8AfXb/ADqR/AXiiNdzaRMR7YNAHO0VevNF1TT/APj70+5hHq8ZFUc0AGK1tJ8T6zokgax1CZFH/LMsWU/gayaKAPZvDPxft7p0ttchFvIePPQ/IfqO1enQXEN1Cs0EiSRuMqytkGvkvFdZ4N8c3vhe8SN3abT2IDxHnb7igD6MxxRiqmm6jb6rYxXlrIHikGQRVygBjRI/3kU/UZqFrC0f71rA31jBqzRQBmTeHtHuAfN0y0bPrCv+FZN78OvC96pDaXFEx/ih+Q/pXU0UAeMeJ/hG9nbvdaLcvKqDJgl649jXlzAqxVlKsOCCORX1df3UNlYzXE7BY0Uk5NfLerXUd7rF3cxDEckhKj2oAqUUVJb28t3cx20Cl5ZDhVHegDsfhbp0t54vinVT5UIO9h2NfQY6VzHgjwtF4Z0VIyoN1KA0r9yfSuooAKQnFNklSGNpJGCooySewryDxr8U5HeTT9Bfaoyr3OOT/u0Ad/4h8b6L4bQi7uA8/aCM5c/4V5Vrvxb1nUGaPTY1sIezA7n/AD7VwEssk8rSzO0kjHLMxyTTaALF3f3moSmS8uprhz1Mjlqr0UZHegAoqza6bfXzbbS0nnP/AEzjJrYh8C+J5lyukXA/3higDnqK6GXwL4mhGW0i4I/2Rmse706+sGK3dpPAR2kQigCrSjKnIJB9R1oooA6HRfG+v6Eyi3vpJIR/yxmYsv8A9avV/C3xT0zWSltqCiyujwCzfIx9j2rwek6c96APrhXDAFSCD0Ip1eF+AviLcaVPHpuqymWzY7UkPVP/AK1e4RSpNGskbBkYZVh0IoAkooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAqC7nW2tZJmIAVSeamzXJ+PNT+yaP9nU4eY44qKkuSLkaUabq1FBdTzbUbtr7UZ7luruar0g6UtfNylzO7Pu4QUIqK6BRRRUlhRRRQAUUUUAFCqZHVF6uQooNbXhTTv7Q12FWXMaHc3tiqjFyaSIqTUIOT6Hpvh2w/s/RreEjD7ct9a1hSKu1QB0FOr6SnBQioo+Eq1HUqOb6hRRRVmYUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAhrhPiHqW22isUOfMOW9q7qRgqFj0AzXjHiPUP7S1ueYH5QdoH0rkxtXkpPuz0sroe1xCb2RldqKKK8E+wYUUUUAFFFFABRRRQAVt+E9OOo67EGXKR/OT71idq9K+H+nfZ9Oe7YfNMcjPpW+Gp+0qJHHjq/saEpdTslGMCnU0dadX0R8SFFFFABVW9uVtLOWdsDYpPNWc1x/j7U/s2mLaI2JJj+lRUmoQcma0KTq1FBdTzi9uWvL6a5brIxNQ0gpa+abcndn3cIqMVFbIKKKKRQUUUUAFFFFABSH260taOg2LahrVvABkBgzfSnGLk7ImUlFNvY9M8Iab/AGfoUQI+aT5j+NHinQU1nT2KjFxGMowH6VuRoI41RRhVGAKfivoo0Y+yVNnxFTFTeIddb3PBZI3hlaKRdrocMKbXb+OtB8qX+0rdPlP+sAHT3rh814Nak6U+Vn2GFxEcRSU4i0UUVkdIUUUUAFFFFABU9le3Gn3KXFs5WRf1+tQUU02ndCcVJWZ6/wCHPEcGt2oyQlyo+dP6it4dK8Js72fT7tLm3crIp7d69c8PeIIdbsg64WZBh0z0Ne1hMUqi5ZbnymZZc8O/aU/h/I26KQHNLXceSFFFFABRRRQAUUUUANJAyfSvI/GWo/b9ddQcpD8qmvTNcvl07Sbi4PZTivFHkaWRnYkljnJrzswqWioLqe5klDmqOq+glFFFeOfTBRRRQAUUUUAFFFFAAeld/wDDzTcLNfuuCflX6VwMaGaVIgOXIWva9DsRp+k28A6qgzXbgafNVu+h5Wb1/Z4flW8jSHSigUV7h8kFFFFABRRRQAZrzT4meODpMB0nT3/0qUYkcfwD0+td7q98mnaXcXTnAjQkfWvl7U9Qm1TVLi9nYmSVyTzQBVJZmLMSzHkk96KKKACtXQfDmpeI7wQafCWA+/IeFX6motD0mbXNYt9PgB3SH5j6L3r6U0DQrPQNMjsrSIKFHzNjlj6mgDkNA+EukacqS6kWvrjqQ3CD8O9d3a2NrZRiO1tooUHZEAqzRQAUUUUANdFdCrKGB6gjNcnr3w60HXEZvswtbg9JYBt59x0NddRQB8zeKvB+o+FbvZcr5lu/+rnUcH6+lc/X1H4j0i31vRLm0uIwwZCVyOh7V8w3ds1nezWz/eicqaAIqPaiigD0r4S+JXtNTbRp3zBKN0eTwpr2+vlPRbh7XXLKWM4PnKD9M19UwtviRvVQaAH0UUUAFIzqilmIAAySaGYKMnge9eQfEj4g7jJouky+qzzKf0FAGZ8S/HB1a5bSNPk/0SJv3jqfvmvOaPr1ooAM4r1/4WeDDEo1y/j+dh+4Rh0HrXI/D7wfJ4k1VbidSLG3IZiR94+lfQkMKQRLFEoRFGFUDgUAPFBIAyelLXNeOdaOh+GrmdG2zOuyM+9AHnHxO8cSXly+i6dKRbp/rnU/ePpmvMQMU5naV2lc5dzuY+5pKACkpa6TwR4YbxPrqwPkW0Xzyn1HpQAeF/BOq+KJgYE8m1B+adxx+A717BoXwy0DR0V5YTe3A6yT8jPsK6yysoLC0jtraJY4owAqqMCrNAEUMEcEYSKNI0HQKMCpaKKACoZ7aG5jMc0SSIequoINTUUAcD4k+Fmj6sjy2C/YbrqDH9xj7ivFdb0O+8P37Wd/EUcfdYdGHqK+qK434j6BBrHhqaUoPtFuN8bAc0AfPFFGCDtPUHBooAQjIr234S+Jn1Cwk0m5fdLbgbCf7vpXiddZ8Nrx7XxrZxqcCZtpoA+jaKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAQ9K8j8Z6l9u1to1bMcXAHvXp2r3YstMnnJwVQ4+teJSymed5j1dt1edmFS0FFdT2sloc1R1H0GUtFFeOfUBRRRQAUUUUAFFFFAAa9I+H2nCGwkvGGGmPGa87toGu7qKBPvSMAK9t021Wz0+CBRjYgBrvwFPmqcz6HkZxX5KHIt5F2iiivaPlAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooppoAxfFWojT9Emfdh3G1frXjhJYksck8mu0+IOpefeR2KHKINzfWuMrxMfU5qnKuh9Xk9D2dHne8vyCiiiuE9cKKKKACiiigAoopD0oAns7dru8ht0GWdgK9t0+1SzsYYFGAqgV5v4D037TqrXTr8sPKn3r1IdK9bLqdk6nc+bzuveaoroApaKK9M8EKDRSGgBGbaMnpXkPi/UTqGuyBWzFHwtel69fDTtIuJ8/MFIA9TXi7uZJGkPVjmvNzCpaKgup7mSUOao6r2Q2looryD6YKKKKACiiigAooooASu/wDh5pvE19IvOdqH2rgkjaSRY1GSxxxXtWg2I07SLe3A6Lk124Gnz1b9jy82r+yoOK3kaIpaWivcPkSte2kd7Zy28qgo6kHNeLatp0ml6lNauPunKn1Fe4npXGeO9G+12YvYUzLF1x3FcWNoe0hzLdHq5Vi/Y1eSW0jzWikB4pa8M+tCiiigAooooAKKKKACrml6nPpN8lzAxGD8y+oqnSU03F3RM4xlFqSuj27SNUh1ayjuYWByPmHofStGvHPDGuyaLqA3Em3k4dfSvXYZkniWWNgyMMgivewuIVaPmfHZhgnhall8L2JqKB0orqOAKKKKACikNMldYomdjgKMk0AcJ8Q9SwIrGNuTy49q8/FaWvX7ajrU8xPAYqv0rOr57FVPaVWz7TLqHscOl1eoUUUVzncFFFFABRRRQAUlLSZoA6LwZp32/XUdhmKLlq9bUAAAdK5LwFpv2XSjcuuJJjz9K6+vdwNLkp37nyOb1/aYhxWyCiiiuw8sKKKKACiiigDjvidK8Pga+ZCQTtGR9a+dl6Cvpnxtpzar4UvbVBliu7H05r5nKlWZTwVJFABRRRQB6D8IUibxHIz43hfkzXu9fLnhvWpPD+uW+oR8hDhx/s96+lNH1ez1rT47yzlV43GeDyD70AaFFGaKACiiigAoozTJZUijLyOqooyWY4AoAhv50trKeaQgKiEkn6V8tatdLe6zd3KfdkkJH516L8R/iBHqEb6PpMm6DOJph39hXl9ABRRRnFAF/QrR73XrKGMZbzVJ+ma+p4l2xqvoMV4x8I/DL3F82tXEZEUY2xEjhq9pFAC0hIAJPAFLXkXxG+IbxPNommbo3U7ZpiCPwH+NAB8RPiNjzNH0aX5sbZp17ewryPkkkkknqT3pM5JJOSepJ60ZFAC9q6Twl4MvvFd0PKHl2aN+8mbp9BXN9q7Dwp8Q7/wraG0S1huLctuwx2sPxoA950bR7TRNMisrSMLHGMfU+taFeTW3xsgJ/wBJ0eRB6pKG/pW3ZfFvwzckCZ57Yn/npHkfpQB31eW/GqVxo9lEDhTLk16Pp+pWeqWq3NlOk0LdGWuI+LumPfeGUmjUn7O+9selAHhA6UUgIIBpaACvZPgwkX9m3T8ebvwfpXjddb8P/FI8Na3/AKQf9En+Vz/d96APoyioba5huoEngkWSJxlWU5BFTUAFFFFABRRSZFAC1geM76PT/C17NIQP3ZCj1Na19fWun2r3F3OkMSDJZjivA/H/AI3bxPefZrTK6fEfl7Fz60AcWW3sz/3jmiiigArrvhnZPd+M7aVRkQHca5A17l8J/DL6ZpbancxlZ7kDbn+72oA9HFLRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFITjNAHEfELURFZRWSth5DuP0rzit7xhem91+Vc5WH5VrBrwMZU56r8j7LK6PssNHz1FooorlPQCiiigAooooAKKKQ5xx1oA6nwNpou9Z+0OuY4eQfevVAK5nwRpostFWRhhpjvNdP2r3cFS5KWvU+PzWv7XENLZaCiiiiuw80KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKr3Mwt7aWZjwik1YrmPG98bTQnRGw8nAqZz5IuRpSpupNQXU8y1K7N/qVxckk+Y5IqrSClr5qUuaTl3Pu4QUIqK2QUUUVJYUUUUAFFFFABSH260taGh2LajrNvAoz8wY/Smk27ImUlFNs9L8HaaNP0OM/wAUvzmujHSooo1ijVEGAowBUtfSUoKEFFHwuIrOtVlUfUKKKK0MQpDS1HM4jiZz0UZoA4H4h6lnybBGIP3mxXB1o67etf6zcSscqGIX6VnV89iqntKrZ9rl9D2OHjHq9QooornO0KKKKACiiigAoopCcUAdB4O043+uxsRlIfmYV66oxXIeA9NNtpZuXXEkp4PtXYDrXuYCny0+Z9T5LN6/tMRyraItFFFdp5QVFPCs8TxOMqwwRUtFAeZ4p4g0ttJ1eWAjCH5k+lZleqeNdF/tHTTPEuZoeRjuK8q5BIPUcH618/i6PsqlujPssuxXt6KvutxaKKK5j0AooooAKKKKACiiigBK7zwL4gIP9mXL+8ZP8q4SnRSyQTJNGcOhyprWjVdOakjmxWHjiKTpy/4Y97HSjNY/h3WE1fS45QcuoCv9a2BX0UJKcVJHxNSnKnNwluhaKKKogD0rnvF+o/2foUp/ik+QfjXQHpXmvxCvjLfw2qt8qDLD3rDE1PZ02zrwNH21eMTix6nqaWiivnT7e1gooooAKKKKACiiigAqxYWhvtQhtgD+8YA4qvXYfD/TftGoSXrjMcYwPrWlKDnNRRjiKqpUpTfRHo1nAtraxQKOEUCrFNHWnV9IlZWR8JKTk22FFFFMQUUUUAFFFFADXQOpVhlSMEV8+/EfwnLoOsvewRk2Nw2QQOEPpX0JVPU9MtdWsZLS8iEkTjBB7fSgD5SortfGHw61Dw9K9zZo1zp+chl5ZB7iuKFABWtoXiXVPDlz52n3BRT96JuUb6ismigD2nRvjHp06rHqtrLbSd3j+df8a6+08c+Gr1QYtXtgT/C77T+tfM9JgUAfVH/CQ6Ptz/adpj/rqKo3Xjfw3ZqTLq9tkfwq+4/kK+ZcClwKAPb9W+MWj2ysunW813J2YjYv+Nea+IfHmt+IyY57gwWx/wCWEPA/E965qigAFFFOiiknkWKKNnkbgKoyTQA2un8G+DbvxTqCnY0djGw82UjGfYe9dJ4T+FF3fNHd65m3t+ogB+dvr6V7JY2Frp1oltaQrFCgwqqKAE07TrfS7GK0tUCRRjAAFW6KKACs+80PS9QYtd6fbTsf4pIgT+daFFAHOSeA/DEhJbR7f8AR/KoT8OvCh66PD/303+NdTRQByw+HPhMf8weL/vpv8acPh54VHTR4PzP+NdPRQBzqeBPDKHI0e2/Fc1ai8KaDD/q9Ish/2xBrYooAjhgit0EcMaRoOiouBUN/ZxahZTWk6ho5VKsDVqigD5h8VeHbjw1rUtrMp8ondE+OCPasSvp7xJ4asfE2nta3ic/8s5B95TXgXifwZqnhi4YXETSWpPyToMgj39KAOeoPNAOaKAOk8N+OdY8MEJbzeda5yYJDkfh6V6jpHxf0K7RUvo5rOXHORuXP1FeFUYoA+nbbxj4euwDDq9oc9jIAast4h0dV3NqdoB6+aK+WMUYFAH0peeP/AAxZKS+rQOR/DEdx/SuQ1f4zWcYZNJspJn7STfKv5da8bxRQBsa74o1fxFNv1C7Z0z8sS8IPwrHoooAKKsWVhd6lcrb2VvJPKxwFQZr1nwh8J1gZL7X8PIMMtsp+UfX1oA5/4feAZtZuY9T1GNo7GM5RWGDIf8K91jiWKNURQqqMAAdBRFEkUYjjQKijAAGABT6ACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooASmyKWRlHUin0UAeKeILGey1i4E6MAzZViOGrLr3W60+1vk2XMEcq+jDNZMvgrQpTk2YH+65H8jXk1sBNycos+kw2c0401GpF3R5DRXrP/AAgmg/8APq//AH9b/Gj/AIQTQf8An1f/AL+t/jWX9n1vL7zo/trDef3Hk1Fes/8ACCaD/wA+r/8Af1v8aP8AhBNB/wCfV/8Av63+NH9n1vL7w/tnDef3Hk1Fes/8IJoP/Pq//f1v8aP+EE0H/n1f/v63+NH9n1vL7w/tnDef3Hk1W9Jsm1DVILdByWyfpXp3/CCaD/z6v/39b/GreneFdK0u5Fxa25WUDAYuT/M1Ucvq3V7ETzmhyvlvc1LeJYIUiQYVRgVNSAYpa9hKysj5dtyd3uFFFFMQUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVxXxAsri4sYpolLJESWA5rtaYyB1KsAQeoNZ1Ye0g49zahW9jUVRK9jwOlr2S48KaNdMWksY9x6leM/lVU+BdBP/AC6t/wB/G/xryXl9VaJo+kjneHe6aPJfxor1n/hBNB/59X/7+t/jR/wgmg/8+r/9/W/xpf2fW8vvK/tnDef3Hk1Fes/8IJoP/Pq//f1v8aP+EE0H/n1f/v63+NH9n1vL7w/tnDef3Hk1Fes/8IJoP/Pq/wD39b/Gj/hBNB/59X/7+t/jR/Z9by+8P7Zw3n9x5LXe/DzTSTLfOv8Asoa3f+EE0HH/AB6v/wB/W/xra0/TrfTLVba1TZEvQZzW2HwU4VFKdtDkxubUqlFwpXuy0KWkxS16p88FFFFABVe9jaWzmjX7zKQKsUhGaGCdjwi9t5bS8lhmVldWPUdagr3K70mxvv8Aj5topfdlrLk8FaFISTZ4/wB1iK8epl87+4z6alndLlSmmmeRUV6z/wAIJoP/AD6v/wB/W/xo/wCEE0H/AJ9X/wC/rf41H9n1vL7zb+2cN5/ceTUV6z/wgmg/8+r/APf1v8aP+EE0H/n1f/v63+NH9n1vL7w/tnDef3Hk1Fes/wDCCaD/AM+r/wDf1v8AGj/hBNB/59X/AO/rf40f2fW8vvD+2cN5/ceS1PZWrXt9DbqCfMYA/SvU/wDhBNB/59X/AO/rf41ZsvCWkaddLcW1uVkHQlyf5mmsvq31JlnOHs+W9/Q07K2FpZxQL0RQKs0DgUV7MUoqyPl5Sc5OT6hRRRTJCiiigBrKGUqRkHivMPFXhO4tbp7yziMkDkllUcrXqOKaVBGDgisa9CNaPKzqwmLnhp88TwMgg4IwfQ0V7Xd+H9LvWLT2ULMf4tuDWe3gbQmOfshH0kb/ABrzJZdUWzR78M7oNe8mjySivWf+EE0H/n1f/v63+NH/AAgmg/8APq//AH9b/Gp/s+t5feX/AG1hvP7jyaivWf8AhBNB/wCfV/8Av63+NH/CCaD/AM+r/wDf1v8AGj+z63l94f2zhvP7jyaivWf+EE0H/n1f/v63+NH/AAgmg/8APq//AH9b/Gj+z63l94f2zhvP7jyaivWf+EE0H/n1f/v63+NL/wAIJoP/AD6v/wB/W/xo/s+t/TF/bOG8/uOF8IaydL1ZY3bEEx2tk8CvW1YNgjpXPDwLoKkEWrgg5H71v8a6CGFYI1jTO1RgZOa78JSqUo8szxsyxFDETVSnv1JKKKK7DzRD0ryfxvY3EGtNcSI3lSDKt2Fes1BcWkF3GY54lkQ9mGawxFH20OW514LFfVqyqNXPB8iivYJfBmhzNk2Sqf8AZYiof+EE0H/n1f8A7+t/jXl/2fW/pn0CzrDPdM8mor1n/hBNB/59X/7+t/jR/wAIJoP/AD6v/wB/W/xo/s+t5feP+2cN5/ceTUV6z/wgmg/8+r/9/W/xo/4QTQf+fV/+/rf40f2fW8vvD+2cN5/ceTUletf8IJoP/Pq//f1v8aP+EE0H/n1f/v63+NH9n1vL7xf2zhvP7jyXBYgL1PAr2DwnposNEhBXDyDc31qNPA2hJIrratlSCMyMf610KIsaBVGAOldWEwkqUnKZ5+ZZlTr01Cl8xRS0UV6J4gUUUUAFFFFABRRRQAUUUUANdQ6lWAIPUEVxPiL4YaJrbNNAhsbk874R8pPuK7iigD591f4VeIdNLNbRpfRDoYjhvyNcjdadfWLFbuzngI/56RkV9X4qOW2inGJYkkHoyg0AfJWR60uR619O3Pg/w9dkmbSLRie/lgGs6T4aeFJDzpaj/ddh/WgD5zyKTI9a+il+GHhNTkabn6ysf61cg8A+F7f7mj25P+2C386APmxEeRgsaM7HoFGTW1p3g3xDqrD7NpVxtP8AHIuwfrX0fbaPp1moW2sreID+5GBV3bjjtQB43o3wYuZCsmr36xr3igGT9M16TofhHRvD6AWNkiyY5lYbnP41uUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABUVxbw3ULRTxJJGwwVYZBqWigDzjX/hFpeos82mSNYzHnZjKH8O1ec6r8N/EulFj9iN1EP44Du/TrX0bSYoA+TJ7W5tX2XFvLC3pIhU/rUWa+sZ7G1ulInt4pQeu9Aax7jwR4auSTLo9rk91Taf0oA+Zs0ZHrX0U/wy8JucnTMf7sjD+tCfDHwmhyNMz9ZWP9aAPnTI9alhgmuH2QQySt/dRSx/SvpS38D+GrbBj0e1yO7JuP61rwadaWqgQW0MQHTYgGKAPnXTPAHiXVSpi02SKM/xz/IP15ru9F+DEKFZdYvjKe8UAwPxNesYpRQBm6ToWm6LAIdPs4oFHdV5P1NaVFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9k="

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# CONFIG
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
st.set_page_config(
    page_title="Piki BI Dashboard",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for clean look
st.markdown("""
<style>
    .metric-card {
        background: #f8f9fa; border-radius: 10px;
        padding: 16px; text-align: center; border-left: 4px solid #1f77b4;
    }
    .metric-value { font-size: 28px; font-weight: 700; color: #1f77b4; }
    .metric-label { font-size: 13px; color: #666; margin-top: 4px; }
    .section-header {
        background: linear-gradient(90deg, #1f77b4 0%, #0d5fa3 100%);
        color: white; padding: 10px 18px; border-radius: 8px;
        font-size: 16px; font-weight: 600; margin-bottom: 16px;
    }
    .kpi-ok  { color: #28a745; font-weight: 700; }
    .kpi-bad { color: #dc3545; font-weight: 700; }
    div[data-testid="stTabs"] button { font-size: 15px; font-weight: 600; }
    /* AI Insight card */
    .ai-insight-card {
        background: #fafbff;
        border: 1px solid #e0e6f0;
        border-left: 3px solid #1f77b4;
        border-radius: 8px;
        padding: 14px 18px;
        margin: 8px 0;
        font-size: 13.5px;
        line-height: 1.6;
        color: #2c3e50;
    }
    .ai-insight-card h1, .ai-insight-card h2, .ai-insight-card h3 {
        font-size: 14px !important;
        font-weight: 600 !important;
        color: #1a3a5c !important;
        margin: 8px 0 4px 0 !important;
    }
    .ai-insight-card p { margin: 4px 0 !important; }
    .ai-insight-card ul, .ai-insight-card ol { 
        margin: 4px 0 !important; padding-left: 18px !important; 
    }
    .ai-insight-card li { margin: 2px 0 !important; font-size: 13px !important; }
    .ai-insight-label {
        font-size: 11px;
        font-weight: 600;
        color: #1f77b4;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 6px;
    }
</style>
""", unsafe_allow_html=True)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# CONSTANTS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
FAILED_KPI       = 10          # max failed orders / week
GROWTH_RATE      = 0.012       # 1.2% weekly KPI
KPI_START_YEAR   = 2026
TARGET_RIDERS    = pd.DataFrame({
    'Business City':        ['Masaki','City Centre','Mlimani','Mikocheni','Mbezi',
                             'Kigamboni','Kinondoni','Arusha','Dodoma','Zanzibar','Mwanza'],
    'Weekday Active Riders':[40, 35, 9, 10, 8, 1, 3, 8, 3, 2, 2],
    'Weekend Active Riders':[50, 40, 10, 13, 10, 1, 4, 10, 4, 3, 3]
})
REGIONAL_CITIES  = ['Arusha','Dodoma','Mwanza','Zanzibar']
DAR_CITIES       = ['Mlimani','Mbezi','Masaki','Mikocheni','City Centre','Kinondoni']
OPERATING_HOURS  = list(range(7, 24)) + [0, 1, 2]
DAY_NAMES        = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday']

PRODUCT_MAPPING  = {
    'chapatti':'chapati','chapati - per piece':'chapati',
    'chickenshawarma':'chicken shawarma','tradional wings':'traditional wings',
    'burger':'beef burger','1 pc chicken':'chicken piece (1)','1pc chicken':'chicken piece (1)',
    'plain chips':'regular chips','chips':'regular chips','fries':'regular chips',
    'french fries':'regular chips','french fries - regular':'regular chips',
    'chips (salted crisps)':'regular chips','chips kavu':'regular chips',
    'reg coleslaw':'coleslaw','regular coleslaw':'coleslaw',
    'soda':'soft drinks','soda - 600ml':'soft drinks (600ml)','coke':'coca cola',
    '600ml coke':'coke - 600ml','1.25ltr coke':'coke - 1.25l',
    'dasani water still - 500ml':'water - 500ml','dew drop - 600ml (12 pack)':'water - 600ml',
}

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# HELPERS ‚Äî pure functions, no Streamlit calls
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def millions(x, pos):
    return f'{x/1_000_000:.1f}M'

fmt_millions = FuncFormatter(millions)

def haversine(lat1, lon1, lat2, lon2):
    R = 6371.0
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    a = sin((lat2-lat1)/2)**2 + cos(lat1)*cos(lat2)*sin((lon2-lon1)/2)**2
    return R * 2 * atan2(sqrt(a), sqrt(1-a))

def extract_products(text):
    results = []
    for qty, name in re.findall(r"(\d+)\s*x\s*([^:\n\r]+)", str(text)):
        results.append((name.lower().strip(), int(qty)))
    return results

def standardize_product(name):
    if name in PRODUCT_MAPPING:
        return PRODUCT_MAPPING[name]
    m = process.extractOne(name, PRODUCT_MAPPING.keys(), scorer=fuzz.token_sort_ratio)
    return PRODUCT_MAPPING[m[0]] if m and m[1] >= 80 else name

def compute_delivery_stages(df):
    """Add all delivery stage columns to df (in-place-safe via copy)."""
    df = df.copy()
    for col in ['DELIVERY TIME','ACCEPTED BUSINESS HOUR','ASSIGNED HOUR',
                'ACCEPTED DRIVER HOUR','IN BUSINESS HOUR','PICKUP HOUR','DELIVERY HOUR']:
        if col in df.columns:
            df[col] = pd.to_datetime(df[col], errors='coerce')

    def stage(a, b, default):
        s = (df[b] - df[a]).dt.total_seconds() / 60
        return s.mask(s < 0, default)

    df['Accepted by Business'] = stage('DELIVERY TIME',        'ACCEPTED BUSINESS HOUR', 0).clip(lower=0)
    df['Assigned Time']        = stage('ACCEPTED BUSINESS HOUR','ASSIGNED HOUR',          3)
    df['Accepted by Driver']   = stage('ASSIGNED HOUR',         'ACCEPTED DRIVER HOUR',   3)
    df['Driver to Business']   = stage('ACCEPTED DRIVER HOUR',  'IN BUSINESS HOUR',       7)
    df['Driver in Business']   = stage('IN BUSINESS HOUR',      'PICKUP HOUR',           15)
    df['Pickup to Customer']   = stage('PICKUP HOUR',           'DELIVERY HOUR',         15)

    adt = (df['DELIVERY HOUR'] - df['DELIVERY TIME']).dt.total_seconds() / 60
    adt2 = (df['DELIVERY HOUR'] - df['ACCEPTED BUSINESS HOUR']).dt.total_seconds() / 60
    df['Average Delivery Time'] = adt.mask(adt < 0, adt2).mask(adt2 < 0, 40)
    return df

def categorize_delay(row):
    if row.get('Average Delivery Time', 0) <= 100:
        return ""
    issues = []
    checks = [
        ('Accepted by Business', 30), ('Assigned Time', 30),
        ('Accepted by Driver', 30),   ('Driver to Business', 30),
        ('Driver in Business', 60),   ('Pickup to Customer', 45),
    ]
    for col, limit in checks:
        v = row.get(col, 0)
        if v < 0 or v > limit:
            issues.append(f"{col} Delay")
    return ", ".join(issues) if issues else "Unclassified Delay"

def week_label(period_or_date):
    """Return readable week label from a Period or datetime."""
    try:
        p = pd.Period(period_or_date, freq='W')
        return f"W{p.week} ({p.start_time.strftime('%d %b')})"
    except Exception:
        return str(period_or_date)

def apply_growth_kpi(weekly):
    weekly = weekly.copy()
    weekly['Year'] = weekly['Week'].dt.year
    base = weekly[weekly['Year'] == KPI_START_YEAR].head(1)
    if base.empty:
        weekly['Growth KPI Orders'] = None
        return weekly
    idx = base.index[0]
    weekly['Growth KPI Orders'] = None
    weekly.loc[idx, 'Growth KPI Orders'] = base['Total_Orders'].values[0]
    for i in range(idx+1, len(weekly)):
        weekly.loc[i, 'Growth KPI Orders'] = weekly.loc[i-1, 'Growth KPI Orders'] * (1 + GROWTH_RATE)
    return weekly

def add_distance(df):
    if not all(c in df.columns for c in ['CUSTOMER LATITUDE','CUSTOMER LONGITUDE',
                                          'BUSINESS LATITUDE','BUSINESS LONGITUDE']):
        return df
    df = df.copy()
    df['DISTANCE (km)'] = df.apply(
        lambda r: haversine(r['CUSTOMER LATITUDE'],r['CUSTOMER LONGITUDE'],
                            r['BUSINESS LATITUDE'],r['BUSINESS LONGITUDE']), axis=1)
    bins   = [0, 2, 3, 4, 5, 7, float('inf')]
    labels = ['0-2 km','2-3 km','3-4 km','4-5 km','5-7 km','7+ km']
    df['Distance Category'] = pd.cut(df['DISTANCE (km)'], bins=bins, labels=labels)
    return df

def excel_bytes(df, sheet='Sheet1'):
    buf = io.BytesIO()
    with pd.ExcelWriter(buf, engine='xlsxwriter') as w:
        df.to_excel(w, index=False, sheet_name=sheet)
    buf.seek(0)
    return buf.read()

def format_products_clean(products_text):
    extracted = extract_products(str(products_text))
    if not extracted:
        return ""
    return ", ".join(f"{qty} x {name.title()}" for name, qty in extracted)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# CLAUDE AI HELPERS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def claude_insight(prompt: str, max_tokens: int = 700) -> str:
    try:
        key = os.getenv("CLAUDE_API_KEY")
        if not key:
            return "‚ö†Ô∏è Set CLAUDE_API_KEY environment variable to enable AI insights."
        client = anthropic.Anthropic(api_key=key)
        r = client.messages.create(
            model="claude-sonnet-4-6",
            max_tokens=max_tokens,
            messages=[{"role": "user", "content": prompt}]
        )
        return r.content[0].text
    except Exception as e:
        return f"‚ö†Ô∏è AI insight unavailable: {e}"

def claude_chat_answer(context: str, history: list, question: str) -> str:
    try:
        key = os.getenv("CLAUDE_API_KEY")
        if not key:
            return "‚ö†Ô∏è Set CLAUDE_API_KEY environment variable."
        client = anthropic.Anthropic(api_key=key)
        system = f"""You are a senior BI analyst for a food delivery company in Tanzania.
Answer questions about the dashboard section using this data context:
{context}
Be concise, specific, and use real numbers. If data doesn't support an answer, say so."""
        r = client.messages.create(
            model="claude-sonnet-4-6", max_tokens=600,
            system=system,
            messages=history + [{"role": "user", "content": question}]
        )
        return r.content[0].text
    except Exception as e:
        return f"‚ö†Ô∏è Could not get answer: {e}"

def ai_block(section_key: str, context: str, insight_text: str):
    """Renders insight card + Q&A chat for any section."""
    html_text = insight_text
    st.markdown(
        f'''<div class="ai-insight-card">
<span class="ai-insight-label">ü§ñ AI Insight</span>
{html_text}
</div>''',
        unsafe_allow_html=True
    )

    with st.expander("üí¨ Ask a follow-up question", expanded=False):
        hkey = f"chat_{section_key}"
        if hkey not in st.session_state:
            st.session_state[hkey] = []
        for m in st.session_state[hkey]:
            st.chat_message(m["role"]).markdown(m["content"])
        q = st.chat_input("Ask anything about this section‚Ä¶", key=f"inp_{section_key}")
        if q:
            st.chat_message("user").markdown(q)
            with st.spinner("Thinking‚Ä¶"):
                ans = claude_chat_answer(context, st.session_state[hkey], q)
            st.chat_message("assistant").markdown(ans)
            st.session_state[hkey] += [{"role":"user","content":q},
                                        {"role":"assistant","content":ans}]
        if st.session_state[hkey]:
            if st.button("üóëÔ∏è Clear chat", key=f"clr_{section_key}"):
                st.session_state[hkey] = []
                st.rerun()


def ai_insight_button(section_key: str, label: str, build_fn, *args, **kwargs):
    """On-demand AI insight: shows a styled button, runs insight only when clicked."""
    _sk = f"ai_ins_{section_key}"
    _ctx_sk = f"ai_ctx_{section_key}"
    if _sk not in st.session_state:
        st.session_state[_sk] = None
        st.session_state[_ctx_sk] = None
    st.markdown(f"""
    <div style="margin:14px 0 6px 0;padding:10px 14px;background:linear-gradient(90deg,#f0f4ff,#e8f0fe);
         border-radius:8px;border:1px solid #c5d3f0;display:flex;align-items:center;gap:10px;">
      <span style="font-size:18px;">ü§ñ</span>
      <span style="font-size:13px;color:#3a5280;font-weight:500;">
        AI Insight available ‚Äî click to analyze <b>{label}</b>
      </span>
    </div>""", unsafe_allow_html=True)
    col_btn, col_rst = st.columns([3,1])
    with col_btn:
        if st.button(f"‚ö° Generate AI Insight", key=f"btn_{section_key}",
                     type="primary", use_container_width=True):
            with st.spinner(f"Claude is analyzing {label}‚Ä¶"):
                result = build_fn(*args, **kwargs)
                if isinstance(result, tuple):
                    ins_text, ctx_text = result
                else:
                    ins_text, ctx_text = result, ""
            st.session_state[_sk] = ins_text
            st.session_state[_ctx_sk] = ctx_text
    with col_rst:
        if st.session_state[_sk] and st.button("‚Ü∫ Refresh", key=f"ref_{section_key}"):
            st.session_state[_sk] = None
            st.rerun()
    if st.session_state[_sk]:
        ai_block(section_key, st.session_state[_ctx_sk] or "", st.session_state[_sk])

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# INSIGHT BUILDERS ‚Äî return (text, context)
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def build_trend_insight(weekly, full_df):
    ws = weekly[['Week_Label','Total_Orders','Growth KPI Orders','Total_Sales']].to_string(index=False)
    wow = ""
    prev_lbl = None
    if len(weekly) >= 2:
        l, p = weekly.iloc[-1], weekly.iloc[-2]
        do = l['Total_Orders'] - p['Total_Orders']
        ds = l['Total_Sales']  - p['Total_Sales']
        prev_lbl = p['Week_Label']
        wow = (f"WoW Orders: {do:+.0f} ({do/max(p['Total_Orders'],1)*100:+.1f}%)\n"
               f"WoW Sales:  {ds:+,.0f} TZS ({ds/max(p['Total_Sales'],1)*100:+.1f}%)")

    # ‚îÄ‚îÄ Business-level movers ‚îÄ‚îÄ
    contrib = ""
    if prev_lbl and 'BUSINESS NAME' in full_df.columns:
        _df = full_df.copy()
        _df['wl'] = (_df['DELIVERY DATE'].dt.isocalendar().year.astype(str)
                     + "-W" + _df['DELIVERY DATE'].dt.isocalendar().week.astype(str).str.zfill(2))
        lbl = weekly.iloc[-1]['Week_Label']
        lb = _df[_df['wl']==lbl].groupby('BUSINESS NAME').agg(
            Latest=('ID','count'), Sales_L=('SUBTOTAL','sum')).reset_index()
        pb = _df[_df['wl']==prev_lbl].groupby('BUSINESS NAME').agg(
            Prev=('ID','count'), Sales_P=('SUBTOTAL','sum')).reset_index()
        bz = pd.merge(lb, pb, on='BUSINESS NAME', how='outer').fillna(0)
        bz['Order_Œî'] = bz['Latest'] - bz['Prev']
        bz['Sales_Œî'] = bz['Sales_L'] - bz['Sales_P']
        bz = bz.sort_values('Order_Œî', ascending=False)
        contrib = (f"\nBUSINESS MOVERS (latest vs prev week):"
                   f"\nTop Growers:\n{bz.head(6)[['BUSINESS NAME','Latest','Prev','Order_Œî','Sales_Œî']].to_string(index=False)}"
                   f"\nTop Decliners:\n{bz.tail(6)[['BUSINESS NAME','Latest','Prev','Order_Œî','Sales_Œî']].to_string(index=False)}")

    # ‚îÄ‚îÄ City performance vs KPI ‚îÄ‚îÄ
    city_ctx = ""
    if 'BUSINESS CITY' in full_df.columns and len(weekly) >= 2:
        _df2 = full_df.copy()
        _df2['wl'] = (_df2['DELIVERY DATE'].dt.isocalendar().year.astype(str)
                      + "-W" + _df2['DELIVERY DATE'].dt.isocalendar().week.astype(str).str.zfill(2))
        lbl = weekly.iloc[-1]['Week_Label']
        kpi_rate = GROWTH_RATE  # e.g. 0.012

        _city_l = (_df2[_df2['wl']==lbl].groupby('BUSINESS CITY')
                   .agg(Orders_Now=('ID','count'), Sales_Now=('SUBTOTAL','sum')).reset_index())
        _city_p = (_df2[_df2['wl']==prev_lbl].groupby('BUSINESS CITY')
                   .agg(Orders_Prev=('ID','count')).reset_index())
        _city_m = pd.merge(_city_l, _city_p, on='BUSINESS CITY', how='outer').fillna(0)
        _city_m['Orders_WoW_%'] = (
            (_city_m['Orders_Now'] - _city_m['Orders_Prev']) /
            _city_m['Orders_Prev'].replace(0, 1) * 100).round(1)
        _city_m['KPI_Target'] = (_city_m['Orders_Prev'] * (1 + kpi_rate)).round(0)
        _city_m['vs_KPI'] = (_city_m['Orders_Now'] - _city_m['KPI_Target']).round(0)
        _city_m['Status'] = _city_m['vs_KPI'].apply(
            lambda x: '‚úÖ Beat KPI' if x >= 0 else f'‚ùå Miss by {abs(int(x))}')
        _city_m = _city_m.sort_values('Orders_WoW_%', ascending=False)
        city_ctx = f"\n\nCITY PERFORMANCE vs 1.2% GROWTH KPI:\n{_city_m[['BUSINESS CITY','Orders_Prev','Orders_Now','Orders_WoW_%','vs_KPI','Status']].to_string(index=False)}"

    context = (f"WEEKLY TREND (all weeks):\n{ws}\n\n"
               f"CURRENT WEEK: {weekly.iloc[-1]['Week_Label']} | "
               f"Orders: {int(weekly.iloc[-1]['Total_Orders'])} | "
               f"Sales: {weekly.iloc[-1]['Total_Sales']/1e6:.2f}M TZS\n\n"
               f"WEEK-OVER-WEEK:\n{wow}{contrib}{city_ctx}")

    prompt = f"""You are a senior BI analyst for Piki, a Tanzanian food delivery company.
{context}

Write a comprehensive weekly executive report. Structure it exactly as:

**1. Overall Performance**
State clearly: is the business growing, flat or declining? What is the trend direction over the last 3 weeks?

**2. KPI Scorecard ‚Äî Cities**
For EACH city, state: orders this week vs last week, % change, whether they beat or missed the 1.2% growth KPI, and a one-line recommendation. Present as clear text (not just numbers).

**3. Top Movers This Week**
Which businesses drove the biggest gains? Which had the biggest drops? Give specific numbers.

**4. Sales vs Orders**
Is average order value changing? Are we getting bigger or smaller orders?

**5. Priority Actions**
3 specific, numbered actions for the operations team ‚Äî each tied to a city or business with real numbers.

Be specific. Use exact numbers from the data. Write like a real analyst report, not a bullet dump."""
    return claude_insight(prompt, 1400), context


def build_failed_insight(failed_weekly, pivot_df=None, week_label_str=None):
    ws = failed_weekly[['Week_Label','Failed Orders']].to_string(index=False)
    context = f"FAILED ORDERS TREND (KPI‚â§{FAILED_KPI}/week):\n{ws}"
    if pivot_df is not None:
        context += f"\n\nWEEKLY BREAKDOWN ‚Äî {week_label_str}:\n{pivot_df.to_string()}"
    prompt = f"""Senior operations analyst for a Tanzanian food delivery company.
{context}
Provide:
1. **Trend** ‚Äì Improving, worsening or stable?
2. **KPI Breaches** ‚Äì Which weeks & by how much?
3. **City / Day Patterns** ‚Äì Where do failures concentrate?
4. **Root Cause Hypotheses** ‚Äì What operational factors likely cause these?
5. **Actions** ‚Äì 3 specific fixes for the highest-risk areas.
Use real numbers."""
    return claude_insight(prompt, 750), context


def build_delivery_insight(stage_df, city):
    summary = stage_df[['BUSINESS CITY','Average Delivery Time','Driver in Business',
                         'Pickup to Customer','Accepted by Business']].head(30).to_string(index=False)
    context = f"DELIVERY STAGE DATA ‚Äî {city}:\n{summary}"
    prompt = f"""Senior BI analyst for a Tanzanian food delivery company.
{context}
Provide:
1. **Overall Speed** ‚Äì Is avg delivery time acceptable (<45 min target)?
2. **Bottleneck Stage** ‚Äì Which stage contributes most to delays?
3. **City Comparison** ‚Äì Best vs worst performing areas.
4. **Vendor Prep Risk** ‚Äì Is Driver-in-Business time too high?
5. **Actions** ‚Äì 2 specific fixes for the biggest delay source.
Use real numbers."""
    return claude_insight(prompt, 700), context


def build_attendance_insight(pivot_df, week_sel, df_week):
    deficiency_cities = pivot_df[pivot_df['Avg Deficiency'] > 0][
        ['WORKING ZONE','Avg Deficiency','Status']].to_string(index=False)
    ok_cities = pivot_df[pivot_df['Avg Deficiency'] == 0]['WORKING ZONE'].tolist()
    total_drivers = df_week['DRIVER NAME'].nunique() if not df_week.empty else 0
    context = (f"DRIVER ATTENDANCE ‚Äî Week {week_sel}\n"
               f"Total unique drivers active: {total_drivers}\n"
               f"Cities with deficiency:\n{deficiency_cities}\n"
               f"Cities at target: {', '.join(ok_cities)}")
    prompt = f"""Senior operations analyst for a Tanzanian food delivery company.
{context}
Provide:
1. **Attendance Summary** ‚Äì How many cities are understaffed vs sufficient?
2. **Highest Risk Zones** ‚Äì Which areas need urgent rider recruitment?
3. **Day Patterns** ‚Äì Are deficiencies on weekdays, weekends or both?
4. **Impact on Delivery** ‚Äì Link understaffing to potential delivery delays.
5. **Actions** ‚Äì Specific staffing recommendations per city.
Use real numbers."""
    return claude_insight(prompt, 700), context


def build_product_insight(total_df, biz_df, weekly_prod_df):
    top10 = total_df.head(10).to_string(index=False)
    top_biz = biz_df.head(10).to_string(index=False)
    total_qty = int(total_df['Total Quantity'].sum())
    top3_share = round(total_df.head(3)['Total Quantity'].sum() / total_qty * 100, 1) if total_qty else 0
    context = (f"PRODUCT MIX ‚Äî Total items sold: {total_qty:,}\n"
               f"Top-3 share: {top3_share}% of volume\n\n"
               f"Top 10 Products:\n{top10}\n\n"
               f"Top 10 Businesses:\n{top_biz}")
    prompt = f"""Senior BI analyst for a Tanzanian food delivery company.
{context}
Provide:
1. **Best Sellers** ‚Äì What dominates and what does it reveal about customer preferences?
2. **Concentration Risk** ‚Äì Over-reliance on few products or businesses?
3. **Business Performance** ‚Äì Revenue vs volume outliers in top businesses.
4. **Menu Opportunity** ‚Äì Underperforming categories worth promoting.
5. **Actions** ‚Äì One for the product team, one for the commercial team.
Use real numbers. Be concise."""
    return claude_insight(prompt, 750), context


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# SIDEBAR ‚Äî Upload & Global Filters
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
with st.sidebar:
    st.markdown(f'<img src="data:image/jpeg;base64,{PIKI_LOGO_B64}" style="width:100%;border-radius:8px;margin-bottom:8px;" />', unsafe_allow_html=True)
    st.title("üìä Piki Dashboard")
    st.divider()

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # DATA SOURCE ‚Äî Supabase PostgreSQL (primary)
    # Falls back to CSV upload if DB not configured
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    # Read secrets (works both locally and on Streamlit Cloud)
    def _get_secret(key, default=None):
        """Read from st.secrets first, then env vars."""
        try:
            return st.secrets[key]
        except Exception:
            return os.getenv(key, default)

    SUPABASE_URL = _get_secret("SUPABASE_URL", "")
    SUPABASE_KEY = _get_secret("SUPABASE_KEY", "")
    DB_TABLE     = _get_secret("DB_TABLE", "orders")

    def _parse_dates(df):
        df['DELIVERY DATE'] = pd.to_datetime(df['DELIVERY DATE'], errors='coerce')
        df['DELIVERY TIME'] = pd.to_datetime(df['DELIVERY TIME'], errors='coerce')
        return df

    # ‚îÄ‚îÄ Try Supabase (load ALL data, no date restriction) ‚îÄ‚îÄ
    def _load_from_supabase(url, key, table):
        """Load ALL orders from Supabase in paginated batches."""
        try:
            from supabase import create_client
            client = create_client(url, key)
            all_rows, page = [], 0
            PAGE = 1000
            while True:
                resp = (client.table(table)
                        .select("*")
                        .order("DELIVERY DATE", desc=True)
                        .range(page * PAGE, (page + 1) * PAGE - 1)
                        .execute())
                rows = resp.data
                all_rows.extend(rows)
                if len(rows) < PAGE:
                    break
                page += 1
            if not all_rows:
                return None, "No data found in database table."
            return pd.DataFrame(all_rows), None
        except ImportError:
            return None, "supabase package not installed."
        except Exception as e:
            return None, str(e)

    # ‚îÄ‚îÄ Default data file ‚Äî auto-loads when app opens ‚îÄ‚îÄ
    DEFAULT_CSV = "February Week 3.csv"   # keep this file in the same folder as Weekly_Report.py

    def _try_load_default():
        """Load the default CSV from the same directory as this script."""
        _try_paths = [
            DEFAULT_CSV,
            os.path.join(os.path.dirname(os.path.abspath(__file__)), DEFAULT_CSV),
        ]
        for _p in _try_paths:
            if os.path.exists(_p):
                try:
                    return pd.read_csv(_p, encoding='utf-8', on_bad_lines='skip'), _p
                except Exception:
                    try:
                        return pd.read_csv(_p, encoding='latin-1', on_bad_lines='skip'), _p
                    except Exception:
                        pass
        return None, None

    # ‚îÄ‚îÄ Optional file override (always visible in sidebar) ‚îÄ‚îÄ
    with st.expander("üìÇ Upload different file (optional)", expanded=False):
        _uploaded = st.file_uploader(
            "CSV or Excel ‚Äî replaces the default dataset",
            type=["csv", "xlsx"],
            key="override_upload",
            label_visibility="collapsed"
        )
        st.caption(f"Default: **{DEFAULT_CSV}** (auto-loaded)")

    _load_btn = st.button("üîÑ Refresh Data", type="secondary", use_container_width=True)

    # ‚îÄ‚îÄ Load logic: DB ‚Üí Upload ‚Üí Default CSV ‚îÄ‚îÄ
    if _load_btn or "raw_df" not in st.session_state:
        if SUPABASE_URL and SUPABASE_KEY:
            with st.spinner("Loading from database‚Ä¶"):
                _df_raw, _err = _load_from_supabase(SUPABASE_URL, SUPABASE_KEY, DB_TABLE)
            if _df_raw is not None:
                raw = _parse_dates(_df_raw)
                st.session_state.raw_df  = raw
                st.session_state["_src"] = "database"
                st.success(f"‚úÖ {len(raw):,} rows from database")
            else:
                st.error(f"‚ùå DB error: {_err}")
                st.stop()
        elif _uploaded:
            with st.spinner(f"Reading {_uploaded.name}‚Ä¶"):
                try:
                    raw = (pd.read_csv(_uploaded, encoding='utf-8', on_bad_lines='skip')
                           if _uploaded.name.endswith(".csv") else pd.read_excel(_uploaded))
                    raw = _parse_dates(raw)
                    st.session_state.raw_df  = raw
                    st.session_state["_src"] = _uploaded.name
                    st.success(f"‚úÖ {len(raw):,} rows from **{_uploaded.name}**")
                except Exception as _ue:
                    st.error(f"‚ùå Cannot read file: {_ue}")
                    st.stop()
        else:
            # Auto-load default CSV ‚Äî silent on success (no spinner needed for local file)
            _def_df, _def_path = _try_load_default()
            if _def_df is not None:
                raw = _parse_dates(_def_df)
                st.session_state.raw_df  = raw
                st.session_state["_src"] = DEFAULT_CSV
            elif "raw_df" not in st.session_state:
                st.error(f"‚ö†Ô∏è **{DEFAULT_CSV}** not found in app folder.")
                st.info("Place the file next to Weekly_Report.py, or expand 'üìÇ Upload' above.")
                st.stop()

    raw = st.session_state.raw_df
    _src_lbl = st.session_state.get("_src", DEFAULT_CSV)
    st.markdown(f"üìä **{len(raw):,} rows** ‚Äî `{_src_lbl}`")

    st.divider()
    st.subheader("üîç Global Filters")

    # ‚îÄ‚îÄ Date range ‚Äî default last 8 weeks (clamped to actual data range) ‚îÄ‚îÄ
    max_date = raw['DELIVERY DATE'].max()
    min_date = raw['DELIVERY DATE'].min()
    _8w_ago = (max_date - pd.Timedelta(weeks=8)).date()
    # Clamp: default_from must be >= min_date
    default_from_8w = max(_8w_ago, min_date.date())
    default_to_8w   = max_date.date()

    date_range = st.date_input(
        "Date Range",
        value=[default_from_8w, default_to_8w],
        min_value=min_date.date(),
        max_value=max_date.date(),
        help="Defaults to last 8 weeks for trend analysis. Narrow down as needed."
    )

    cities = sorted(raw['BUSINESS CITY'].dropna().unique())
    city_sel = st.multiselect("Business City", cities, placeholder="All cities")

    businesses = sorted(raw['BUSINESS NAME'].dropna().unique())
    biz_sel = st.multiselect("Business Name", businesses, placeholder="All businesses")

    hour_opt = st.selectbox("Time Period",
        ["All Day","Morning (7‚Äì11)","Afternoon (12‚Äì16)","Evening (17‚Äì22)",
         "Late Night (23‚Äì2)","Custom"])
    custom_hours = []
    if hour_opt == "Custom":
        custom_hours = st.multiselect("Hours", OPERATING_HOURS)

    st.divider()
    st.caption(f"Data spans {min_date.date()} ‚Üí {max_date.date()}")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# APPLY GLOBAL FILTERS ‚Üí produce `df`
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
df = raw.copy()

if len(date_range) == 2:
    df = df[(df['DELIVERY DATE'] >= pd.to_datetime(date_range[0])) &
            (df['DELIVERY DATE'] <= pd.to_datetime(date_range[1]))]
if city_sel:
    df = df[df['BUSINESS CITY'].isin(city_sel)]
if biz_sel:
    df = df[df['BUSINESS NAME'].isin(biz_sel)]

df['HOUR'] = df['DELIVERY TIME'].dt.hour
df = df[df['HOUR'].isin(OPERATING_HOURS)]

if hour_opt == "Morning (7‚Äì11)":
    df = df[df['HOUR'].between(7, 11)]
elif hour_opt == "Afternoon (12‚Äì16)":
    df = df[df['HOUR'].between(12, 16)]
elif hour_opt == "Evening (17‚Äì22)":
    df = df[df['HOUR'].between(17, 22)]
elif hour_opt == "Late Night (23‚Äì2)":
    df = df[(df['HOUR'] >= 23) | (df['HOUR'] <= 2)]
elif hour_opt == "Custom" and custom_hours:
    df = df[df['HOUR'].isin(custom_hours)]

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# HEADER
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
st.title("üìä Piki Weekly Business Intelligence")

city_label = ", ".join(city_sel) if city_sel else "All Cities"
biz_label  = f"{len(biz_sel)} businesses" if biz_sel else "All Businesses"
st.markdown(
    f"**Active filters:** üìÖ `{date_range[0]} ‚Üí {date_range[1]}` &nbsp;|&nbsp; "
    f"üèôÔ∏è `{city_label}` &nbsp;|&nbsp; üè™ `{biz_label}` &nbsp;|&nbsp; ‚è∞ `{hour_opt}`"
)

if df.empty:
    st.error("No data matches the current filters. Adjust the filters in the sidebar.")
    st.stop()

# ‚îÄ‚îÄ Quick KPI bar ‚îÄ‚îÄ
col1, col2, col3, col4, col5 = st.columns(5)
total_orders  = len(df)
total_sales   = df['SUBTOTAL'].sum() if 'SUBTOTAL' in df.columns else 0
total_failed  = len(df[df['STATE'] == 'Delivery Failed By Driver']) if 'STATE' in df.columns else 0
unique_biz    = df['BUSINESS NAME'].nunique()
unique_drivers = df['DRIVER NAME'].nunique() if 'DRIVER NAME' in df.columns else 0

col1.metric("üì¶ Total Orders",  f"{total_orders:,}")
col2.metric("üí∞ Total Sales",   f"{total_sales/1_000_000:.1f}M TZS")
col3.metric("‚ùå Failed Orders", f"{total_failed}")
col4.metric("üè™ Active Businesses", f"{unique_biz}")
col5.metric("üö¥ Active Riders", f"{unique_drivers}")

st.divider()

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# MAIN TABS
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tab1, tab2, tab3, tab4, tab5 = st.tabs([
    "üìà Weekly Trends",
    "‚è∞ Delivery Times",
    "üö¥ Rider Attendance",
    "üì¶ Products & Geo",
    "üéâ Piki Party Store",
])

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TAB 1 ‚Äî WEEKLY TRENDS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
with tab1:
    st.markdown('<div class="section-header">üìà Orders & Sales KPI Trend</div>', unsafe_allow_html=True)

    # ‚îÄ‚îÄ Weekly aggregation ‚îÄ‚îÄ
    weekly = (
        df.groupby(df['DELIVERY DATE'].dt.to_period('W-SUN'))
        .agg(Total_Orders=('ID','count'), Total_Sales=('SUBTOTAL','sum'))
        .reset_index()
    )
    weekly['Week']       = weekly['DELIVERY DATE'].dt.start_time
    weekly['Week_Label'] = weekly['DELIVERY DATE'].apply(
        lambda p: f"W{p.week} ({p.start_time.strftime('%d %b')})"
    )
    weekly = apply_growth_kpi(weekly)

    # ‚îÄ‚îÄ Chart ‚îÄ‚îÄ
    fig, ax1 = plt.subplots(figsize=(13, 5))
    ax1.plot(weekly['Week_Label'], weekly['Total_Orders'],
             color='#1f77b4', marker='o', lw=2, label='Total Orders')
    if 'Growth KPI Orders' in weekly.columns:
        ax1.plot(weekly['Week_Label'], weekly['Growth KPI Orders'],
                 color='green', lw=2, linestyle='--', label='1.2% Growth KPI')
    ax1.set_ylabel("Orders"); ax1.grid(True, alpha=0.3)
    ax2 = ax1.twinx()
    ax2.bar(weekly['Week_Label'], weekly['Total_Sales'],
            alpha=0.25, color='#ff7f0e', label='Sales (TZS)')
    ax2.set_ylabel("Sales (TZS)"); ax2.yaxis.set_major_formatter(fmt_millions)
    lines1, labels1 = ax1.get_legend_handles_labels()
    lines2, labels2 = ax2.get_legend_handles_labels()
    ax1.legend(lines1+lines2, labels1+labels2, loc='upper left', fontsize=9)
    plt.title("Weekly Orders vs Sales vs KPI"); plt.xticks(rotation=30, ha='right')
    plt.tight_layout(); st.pyplot(fig); plt.close()

    st.dataframe(
        weekly[['Week_Label','Total_Orders','Growth KPI Orders','Total_Sales']].rename(
            columns={'Week_Label':'Week','Total_Orders':'Orders',
                     'Growth KPI Orders':'KPI Target','Total_Sales':'Sales (TZS)'}
        ), use_container_width=True
    )

    # ‚îÄ‚îÄ Regional Manager Excel Download ‚îÄ‚îÄ
    st.markdown('<div class="section-header">üì• Regional Manager Report ‚Äî Download by City</div>', unsafe_allow_html=True)
    st.caption("One Excel sheet per city: weekly summary, operations KPIs with issue filtering, top vendors, top drivers.")

    _reg_btn_key = "reg_report_ready"
    if _reg_btn_key not in st.session_state:
        st.session_state[_reg_btn_key] = None

    if st.button("‚öôÔ∏è Generate Regional Report", key="btn_regional_excel", type="secondary", use_container_width=False):
        from openpyxl import Workbook as _OXLWorkbook
        from openpyxl.styles import Font as _OXLFont, PatternFill as _OXLFill
        from openpyxl.utils.dataframe import dataframe_to_rows as _df2rows

        _reg_wb = _OXLWorkbook()
        _reg_wb.remove(_reg_wb.active)

        # ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        def _categorize_issues(row):
            issues = []
            if row['Accepted by Business'] < 0 or row['Accepted by Business'] > 30:
                issues.append("Accepted by Business Out of Range")
            if row['Assigned Time'] < 0 or row['Assigned Time'] > 30:
                issues.append("Assigned Time Out of Range")
            if row['Accepted by Driver'] < 0 or row['Accepted by Driver'] > 45:
                issues.append("Accepted by Driver Out of Range")
            if row['Driver to Business'] < 0 or row['Driver to Business'] > 45:
                issues.append("Driver to Business Out of Range")
            if row['Driver in Business'] < 0 or row['Driver in Business'] > 90:
                issues.append("Driver in Business Out of Range")
            if row['Pickup to Customer'] < 0 or row['Pickup to Customer'] > 45:
                issues.append("Pickup to Customer Out of Range")
            if row['Average Delivery Time'] < 0 or row['Average Delivery Time'] > 100:
                issues.append("Average Delivery Time Out of Range")
            return ", ".join(issues)

        def _reg_write_section(_ws, title, dataframe, start_row):
            if dataframe is None or dataframe.empty:
                return start_row + 2
            _ws.merge_cells(start_row=start_row, start_column=1,
                            end_row=start_row, end_column=max(len(dataframe.columns), 1))
            _tc = _ws.cell(row=start_row, column=1, value=title)
            _tc.font = _OXLFont(bold=True, color="FFFFFF")
            _tc.fill = _OXLFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
            for _r_i, _row in enumerate(_df2rows(dataframe, index=False, header=True), start=start_row+1):
                for _c_i, _val in enumerate(_row, start=1):
                    _cell = _ws.cell(row=_r_i, column=_c_i, value=_val)
                    if _r_i == start_row + 1:  # header row
                        _cell.font = _OXLFont(bold=True)
                        _cell.fill = _OXLFill(start_color="FFC000", end_color="FFC000", fill_type="solid")
            return start_row + len(dataframe) + 3

        # ‚îÄ‚îÄ Build per-city sheets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        _reg_cities = sorted(df['BUSINESS CITY'].dropna().unique())
        _df_completed_all = df[df['STATE'].isin(['Delivery Completed By Driver','Completed'])].copy()

        # Ensure datetime columns parsed on the full dataframe
        for _tc_col in ['DELIVERY TIME','ACCEPTED BUSINESS HOUR','ASSIGNED HOUR',
                         'ACCEPTED DRIVER HOUR','IN BUSINESS HOUR','PICKUP HOUR','DELIVERY HOUR']:
            if _tc_col in _df_completed_all.columns:
                _df_completed_all[_tc_col] = pd.to_datetime(_df_completed_all[_tc_col], errors='coerce')

        _prog = st.progress(0, text="Building city reports‚Ä¶")
        for _ci, _rcity in enumerate(_reg_cities):
            _prog.progress(int((_ci / max(len(_reg_cities), 1)) * 100),
                           text=f"Building: {_rcity}‚Ä¶")

            _df_c   = df[df['BUSINESS CITY'] == _rcity].copy()
            _df_c_c = _df_completed_all[_df_completed_all['BUSINESS CITY'] == _rcity].copy()
            if _df_c.empty:
                continue

            # Week label using period (matches the main dashboard format)
            _df_c['Week']   = _df_c['DELIVERY DATE'].dt.to_period('W-SUN').apply(
                lambda p: f"Week {p.week} ({p.start_time.strftime('%d %b')})")
            if not _df_c_c.empty:
                _df_c_c['Week'] = _df_c_c['DELIVERY DATE'].dt.to_period('W-SUN').apply(
                    lambda p: f"Week {p.week} ({p.start_time.strftime('%d %b')})")

            # ‚îÄ‚îÄ Weekly summary ‚îÄ‚îÄ
            _wk_sum = (_df_c.groupby('Week', sort=False)
                       .agg(**{'Total Orders': ('ID','count')})
                       .reset_index())
            if not _df_c_c.empty:
                _wk_sum['Completed Orders'] = (_df_c_c.groupby('Week')['ID'].count()
                                               .reindex(_wk_sum['Week'], fill_value=0).values)
                _wk_sum['Total Sales (TZS)'] = (_df_c_c.groupby('Week')['SUBTOTAL'].sum()
                                                .reindex(_wk_sum['Week'], fill_value=0).values)
            else:
                _wk_sum['Completed Orders']  = 0
                _wk_sum['Total Sales (TZS)'] = 0

            # ‚îÄ‚îÄ Operations KPIs ‚Äî exact logic from reference code ‚îÄ‚îÄ
            _df_ops = _df_c_c.copy() if not _df_c_c.empty else pd.DataFrame()
            _ops_kpi = pd.DataFrame()
            if not _df_ops.empty:
                # Calculate each stage
                _df_ops['Accepted by Business'] = (
                    (_df_ops['ACCEPTED BUSINESS HOUR'] - _df_ops['DELIVERY TIME'])
                    .dt.total_seconds() / 60)
                _df_ops['Accepted by Business'] = _df_ops['Accepted by Business'].mask(
                    _df_ops['Accepted by Business'] < 0, 0)

                _df_ops['Assigned Time'] = (
                    (_df_ops['ASSIGNED HOUR'] - _df_ops['ACCEPTED BUSINESS HOUR'])
                    .dt.total_seconds() / 60)
                _df_ops['Assigned Time'] = _df_ops['Assigned Time'].mask(
                    _df_ops['Assigned Time'] < 0, 3)

                _df_ops['Accepted by Driver'] = (
                    (_df_ops['ACCEPTED DRIVER HOUR'] - _df_ops['ASSIGNED HOUR'])
                    .dt.total_seconds() / 60)
                _df_ops['Accepted by Driver'] = _df_ops['Accepted by Driver'].mask(
                    _df_ops['Accepted by Driver'] < 0, 3)

                _df_ops['Driver to Business'] = (
                    (_df_ops['IN BUSINESS HOUR'] - _df_ops['ACCEPTED DRIVER HOUR'])
                    .dt.total_seconds() / 60)
                _df_ops['Driver to Business'] = _df_ops['Driver to Business'].mask(
                    _df_ops['Driver to Business'] < 0, 7)

                _df_ops['Driver in Business'] = (
                    (_df_ops['PICKUP HOUR'] - _df_ops['IN BUSINESS HOUR'])
                    .dt.total_seconds() / 60)
                _df_ops['Driver in Business'] = _df_ops['Driver in Business'].mask(
                    _df_ops['Driver in Business'] < 0, 15)

                _df_ops['Pickup to Customer'] = (
                    (_df_ops['DELIVERY HOUR'] - _df_ops['PICKUP HOUR'])
                    .dt.total_seconds() / 60)
                _df_ops['Pickup to Customer'] = _df_ops['Pickup to Customer'].mask(
                    _df_ops['Pickup to Customer'] < 0, 15)

                _df_ops['Average Delivery Time'] = (
                    (_df_ops['DELIVERY HOUR'] - _df_ops['DELIVERY TIME'])
                    .dt.total_seconds() / 60)
                _df_ops['Average Delivery Time'] = _df_ops['Average Delivery Time'].mask(
                    _df_ops['Average Delivery Time'] < 0,
                    (_df_ops['DELIVERY HOUR'] - _df_ops['ACCEPTED BUSINESS HOUR'])
                    .dt.total_seconds() / 60)
                _df_ops['Average Delivery Time'] = _df_ops['Average Delivery Time'].mask(
                    _df_ops['Average Delivery Time'] < 0, 40)

                # Filter out rows with out-of-range values (exact logic from reference)
                _df_ops['_Issues'] = _df_ops.apply(_categorize_issues, axis=1)
                _df_ops = _df_ops[_df_ops['_Issues'] == '']

                if not _df_ops.empty and 'Week' in _df_ops.columns:
                    _kpi_metric_cols = ['Accepted by Business','Assigned Time','Accepted by Driver',
                                        'Driver to Business','Driver in Business','Pickup to Customer',
                                        'Average Delivery Time']
                    _ops_kpi = (_df_ops.groupby('Week', sort=False)[_kpi_metric_cols]
                                .mean().round(1).reset_index())
                    _ops_kpi['Average Delivery Time % Change'] = (
                        _ops_kpi['Average Delivery Time'].pct_change() * 100).round(1)

            # ‚îÄ‚îÄ Latest week top lists ‚îÄ‚îÄ
            _latest_wk = _df_c['Week'].max() if not _df_c.empty else None
            _recent    = _df_c[_df_c['Week'] == _latest_wk] if _latest_wk else pd.DataFrame()

            _top_vendors = (
                _recent.groupby('BUSINESS NAME')
                .agg(**{'Total Orders': ('ID','count'), 'Total Sales': ('SUBTOTAL','sum')})
                .reset_index().sort_values('Total Orders', ascending=False).head(10)
            ) if not _recent.empty else pd.DataFrame()

            _top_drivers = (
                _recent.groupby('DRIVER NAME')
                .agg(**{'Total Deliveries': ('ID','count')})
                .reset_index().sort_values('Total Deliveries', ascending=False).head(10)
            ) if not _recent.empty else pd.DataFrame()

            # ‚îÄ‚îÄ Create worksheet ‚îÄ‚îÄ
            _ws = _reg_wb.create_sheet(title=_rcity[:31])
            _cur_row = 1
            _cur_row = _reg_write_section(
                _ws, f"Weekly Summary ‚Äî {_rcity}", _wk_sum, _cur_row)
            _cur_row = _reg_write_section(
                _ws, "Operations KPIs (Completed, outliers filtered)", _ops_kpi, _cur_row)
            _cur_row = _reg_write_section(
                _ws, f"Top 10 Vendors ‚Äî {_latest_wk}", _top_vendors, _cur_row)
            _cur_row = _reg_write_section(
                _ws, f"Top 10 Drivers ‚Äî {_latest_wk}", _top_drivers, _cur_row)

        _prog.progress(100, text="‚úÖ Done!")

        # ‚îÄ‚îÄ Save & store in session ‚îÄ‚îÄ
        _reg_buf = io.BytesIO()
        _reg_wb.save(_reg_buf)
        _reg_buf.seek(0)
        st.session_state[_reg_btn_key] = _reg_buf.getvalue()

    # Show download button once generated
    if st.session_state.get(_reg_btn_key):
        st.download_button(
            "üì• Download Regional Report (Excel)",
            data=st.session_state[_reg_btn_key],
            file_name=f"Weekly_Report_By_City_{pd.Timestamp.today().strftime('%b_%d_%Y')}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            key="dl_regional_excel"
        )
        st.success("‚úÖ Regional report ready ‚Äî one sheet per city with summary, KPIs, vendors and drivers.")
    # ‚îÄ‚îÄ City KPI Summary Table (always visible, no AI needed) ‚îÄ‚îÄ
    if 'BUSINESS CITY' in df.columns and len(weekly) >= 2:
        st.markdown("#### üìä City Performance vs 1.2% Weekly Growth KPI")
        _wl_cur  = weekly.iloc[-1]['Week_Label']
        _wl_prev = weekly.iloc[-2]['Week_Label']
        _df_tr = df.copy()
        _df_tr['wl'] = (_df_tr['DELIVERY DATE'].dt.isocalendar().year.astype(str)
                        + "-W" + _df_tr['DELIVERY DATE'].dt.isocalendar().week.astype(str).str.zfill(2))
        _city_now  = (_df_tr[_df_tr['wl']==_wl_cur].groupby('BUSINESS CITY')
                      .agg(Orders_Now=('ID','count'), Sales_Now=('SUBTOTAL','sum')).reset_index())
        _city_prev = (_df_tr[_df_tr['wl']==_wl_prev].groupby('BUSINESS CITY')
                      .agg(Orders_Prev=('ID','count')).reset_index())
        _city_tbl  = pd.merge(_city_now, _city_prev, on='BUSINESS CITY', how='outer').fillna(0)
        _city_tbl['Orders vs Last Week'] = (
            _city_tbl['Orders_Now'].astype(int).astype(str) + " (" +
            ((_city_tbl['Orders_Now'] - _city_tbl['Orders_Prev'])
             .apply(lambda x: f"{x:+.0f}")) + ")")
        _city_tbl['WoW %'] = (
            (_city_tbl['Orders_Now'] - _city_tbl['Orders_Prev']) /
            _city_tbl['Orders_Prev'].replace(0,1) * 100).round(1)
        _city_tbl['KPI Target (+1.2%)'] = (_city_tbl['Orders_Prev'] * 1.012).round(0).astype(int)
        _city_tbl['vs KPI'] = (_city_tbl['Orders_Now'] - _city_tbl['KPI Target (+1.2%)']).round(0).astype(int)
        _city_tbl['KPI Status'] = _city_tbl['vs KPI'].apply(
            lambda x: '‚úÖ Beat KPI' if x >= 0 else f'‚ùå -{abs(int(x))} orders')
        _city_tbl['Recommendation'] = _city_tbl.apply(lambda r: (
            f"Investigate drop ‚Äî lost {abs(int(r['vs KPI']))} orders vs target"
            if r['vs KPI'] < -5
            else ("Strong growth ‚Äî sustain momentum" if r['WoW %'] > 5
                  else ("Near target ‚Äî small push needed" if r['vs KPI'] < 0
                        else "On track"))), axis=1)
        _city_tbl['Sales (TZS)'] = _city_tbl['Sales_Now'].apply(lambda x: f"{int(x):,}")
        _kpi_tbl_disp = _city_tbl[['BUSINESS CITY','Orders vs Last Week','WoW %',
                                   'KPI Target (+1.2%)','KPI Status','Sales (TZS)','Recommendation']]
        _kpi_tbl_disp = _kpi_tbl_disp.sort_values('WoW %', ascending=False).reset_index(drop=True)
        _kpi_tbl_disp.index = range(1, len(_kpi_tbl_disp)+1)
        st.dataframe(_kpi_tbl_disp, use_container_width=True)
        st.download_button("‚¨áÔ∏è City KPI Table (Excel)",
            data=excel_bytes(_kpi_tbl_disp.reset_index(drop=True), "City KPI"),
            file_name=f"City_KPI_{_wl_cur}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            key="dl_city_kpi")

    # ‚îÄ‚îÄ Auto-running AI insight ‚îÄ‚îÄ
    _tr_ins_key = "trend_auto_insight"
    if _tr_ins_key not in st.session_state:
        st.session_state[_tr_ins_key] = None
    _tr_ctx_hash = str(hash(weekly['Week_Label'].iloc[-1] + str(weekly['Total_Orders'].iloc[-1])))
    if (st.session_state[_tr_ins_key] is None or
            st.session_state.get(_tr_ins_key + "_hash") != _tr_ctx_hash):
        with st.spinner("ü§ñ Analyzing trend‚Ä¶"):
            _tr_ins, _tr_ctx = build_trend_insight(weekly, df)
            st.session_state[_tr_ins_key] = (_tr_ins, _tr_ctx)
            st.session_state[_tr_ins_key + "_hash"] = _tr_ctx_hash
    if st.session_state[_tr_ins_key]:
        _tr_ins, _tr_ctx = st.session_state[_tr_ins_key]
        ai_block("trend_orders", _tr_ctx, _tr_ins)
    # Refresh button
    _tr_c1, _ = st.columns([2, 3])
    if _tr_c1.button("‚Ü∫ Refresh Trend Insight", key="btn_trend_refresh"):
        st.session_state[_tr_ins_key] = None
        st.rerun()

    st.divider()

    # ‚îÄ‚îÄ Predictive Forecast ‚Äî Claude AI ‚îÄ‚îÄ
    st.markdown('<div class="section-header">üîÆ AI Predictive Forecast (Next 4 Weeks)</div>', unsafe_allow_html=True)

    if len(weekly) >= 4:
        _wr = weekly.copy().reset_index(drop=True)
        _wr['g'] = _wr['Total_Orders'].pct_change()
        avg_g  = _wr['g'].tail(3).mean()
        last_o = int(_wr.iloc[-1]['Total_Orders'])
        last_k = _wr.iloc[-1]['Growth KPI Orders']
        last_w = _wr.iloc[-1]['Week']

        # Build numeric forecast for chart
        preds, po, pk = [], last_o, last_k
        for i in range(1, 5):
            po = po * (1 + avg_g); pk = pk * (1 + GROWTH_RATE)
            preds.append({"Week_Label": f"Forecast W+{i}",
                          "Predicted Orders": int(po), "KPI Target": int(pk),
                          "Week": last_w + pd.Timedelta(days=7*i)})
        fcast = pd.DataFrame(preds)

        risk = ("üî¥ HIGH RISK ‚Äì Declining" if avg_g < 0
                else "üü° MODERATE ‚Äì Below KPI" if avg_g < GROWTH_RATE
                else "üü¢ STABLE GROWTH")

        # Chart: actual + forecast
        fig2, ax2 = plt.subplots(figsize=(13, 5))
        ax2.plot(weekly['Week_Label'], weekly['Total_Orders'],
                 marker='o', color='#1f77b4', lw=2, label='Actual Orders')
        if 'Growth KPI Orders' in weekly.columns:
            ax2.plot(weekly['Week_Label'], weekly['Growth KPI Orders'],
                     linestyle='--', color='green', lw=1.5, label='KPI Trajectory')
        ax2.plot(fcast['Week_Label'], fcast['Predicted Orders'],
                 marker='o', linestyle='--', color='purple', lw=2, label='AI Predicted')
        ax2.plot(fcast['Week_Label'], fcast['KPI Target'],
                 linestyle=':', color='orange', lw=1.5, label='Future KPI Target')
        ax2.axvline(x=len(weekly)-0.5, color='gray', linestyle=':', alpha=0.4)
        ax2.set_xlabel("Week"); ax2.set_ylabel("Orders")
        ax2.legend(); ax2.grid(True, alpha=0.3)
        plt.title("AI Forecast: Actual vs KPI vs Predicted")
        plt.xticks(rotation=30, ha='right'); plt.tight_layout()
        st.pyplot(fig2); plt.close()

        st.dataframe(fcast[['Week_Label','Predicted Orders','KPI Target']],
                     use_container_width=True)

        # Claude AI forecast analysis
        hist_str  = weekly[['Week_Label','Total_Orders']].to_string(index=False)
        fcast_str = fcast[['Week_Label','Predicted Orders','KPI Target']].to_string(index=False)
        _avg_g_pct = round(avg_g * 100, 2)
        _forecast_prompt = (
            "You are a senior BI analyst for a Tanzanian food delivery company.\n\n"
            "HISTORICAL WEEKLY ORDERS:\n" + hist_str + "\n\n"
            "STATISTICAL FORECAST (next 4 weeks, avg 3-week growth = " + str(_avg_g_pct) + "%):\n"
            + fcast_str + "\n\nRisk level: " + risk + "\nKPI target: 1.2% weekly growth\n\n"
            "Provide a forward-looking AI forecast analysis:\n"
            "1. **Growth Trajectory** - Is the forecast realistic given the trend?\n"
            "2. **Risk Assessment** - What could cause actual orders to fall below forecast?\n"
            "3. **Upside Scenarios** - What operational changes could beat the forecast?\n"
            "4. **KPI Gap Analysis** - Will the business likely meet 1.2% growth KPI?\n"
            "5. **Strategic Actions** - 2-3 specific steps to take NOW for the next 4 weeks.\n\n"
            "Be specific, use real numbers, write as a strategic advisor."
        )

        _fc_ctx = "FORECAST:\n" + fcast_str + "\n\nHISTORY:\n" + hist_str + "\nRisk: " + risk
        def _run_forecast_insight():
            return claude_insight(_forecast_prompt, max_tokens=900), _fc_ctx
        ai_insight_button("forecast", "4-Week Forecast", _run_forecast_insight)
    else:
        st.info("Need 4+ weeks of data to generate a forecast.")

    st.divider()

    # ‚îÄ‚îÄ AI Weather Forecast for Coming Week ‚îÄ‚îÄ
    st.markdown('<div class="section-header">üå§Ô∏è Weather Forecast ‚Äî Coming Week (Tanzania)</div>', unsafe_allow_html=True)
    st.caption("AI-predicted weather for key cities. Rain >70% = üî¥ high impact on operations. Download the forecast for regional planning.")

    _wf_btn_key  = "show_weather_forecast"
    _wf_data_key = "weather_forecast_df"
    # Always initialize both keys independently
    if _wf_btn_key  not in st.session_state: st.session_state[_wf_btn_key]  = None
    if _wf_data_key not in st.session_state: st.session_state[_wf_data_key] = None

    _wf_c1, _wf_c2 = st.columns([3, 1])
    with _wf_c1:
        if st.button("üå§Ô∏è Generate Weekly Weather Forecast", key="btn_weather", type="primary", use_container_width=True):
            from datetime import date, timedelta
            _today_date = date.today()
            _days_ahead = [(_today_date + timedelta(days=i)).strftime("%a %d %b") for i in range(1, 8)]
            _days_str   = ", ".join(_days_ahead)

            _weather_prompt = f"""You are a meteorological analyst for Tanzania food delivery operations.

Generate a 7-day weather forecast for the coming week ({_days_str}) for these cities:
Dar es Salaam, Arusha, Dodoma, Zanzibar, Mwanza

Return ONLY a JSON array (no markdown, no explanation) like this:
[
  {{
    "Date": "Mon 24 Feb",
    "City": "Dar es Salaam",
    "Condition": "Partly Cloudy",
    "Temp_C": 31,
    "Rain_Risk_Pct": 25,
    "Rain_Start_Time": "N/A",
    "Delivery_Impact": "Normal",
    "Notes": "Hot afternoon may boost orders"
  }},
  ...
]

Rules:
- Rain_Risk_Pct: integer 0‚Äì100 representing % probability of rain
- Rain_Start_Time: estimated time rain starts if risk > 40%, else "N/A" (e.g. "14:00")
- Delivery_Impact: one of "Boost", "Normal", "Risk"
  * Boost = rainy/very hot conditions drive more food orders
  * Risk = severe storms, flooding risk, extreme conditions that could disrupt riders
  * Normal = standard conditions
- Use February seasonal patterns for East Africa (end of short dry, start of long rains approaching)
- Produce exactly 35 rows (5 cities √ó 7 days)"""

            with st.spinner("üå¶Ô∏è Generating forecast‚Ä¶"):
                _raw_weather = claude_insight(_weather_prompt, max_tokens=1400)

            # Parse JSON ‚Äî use regex to strip markdown fences robustly
            try:
                import json as _json, re as _re
                # Remove ```json ... ``` or ``` ... ``` wrappers
                _clean = _re.sub(r'^```(?:json)?\s*', '', _raw_weather.strip(), flags=_re.MULTILINE)
                _clean = _re.sub(r'\s*```$', '', _clean.strip(), flags=_re.MULTILINE).strip()
                # Find first '[' in case there's preamble text
                _bracket_start = _clean.find('[')
                if _bracket_start > 0:
                    _clean = _clean[_bracket_start:]
                _weather_rows = _json.loads(_clean)
                _wf_df = pd.DataFrame(_weather_rows)
                _wf_df['Rain_Risk_Pct'] = pd.to_numeric(_wf_df.get('Rain_Risk_Pct', 0), errors='coerce').fillna(0).astype(int)
                _wf_df['Temp_C']        = pd.to_numeric(_wf_df.get('Temp_C', 28),       errors='coerce').fillna(28).astype(int)
                st.session_state[_wf_btn_key]  = True
                st.session_state[_wf_data_key] = _wf_df
            except Exception:
                # Store raw text ‚Äî display will handle gracefully
                st.session_state[_wf_btn_key]  = True
                st.session_state[_wf_data_key] = _raw_weather

    if st.session_state.get(_wf_btn_key):
        _wf_df = st.session_state.get(_wf_data_key)
        if isinstance(_wf_df, pd.DataFrame) and not _wf_df.empty:
            # Display city-by-city ‚Äî 5 columns, one per city
            _wf_cities = _wf_df['City'].unique() if 'City' in _wf_df.columns else []
            _wf_cols = st.columns(min(len(_wf_cities), 5))
            for _ci, _wcity in enumerate(_wf_cities):
                with _wf_cols[_ci % len(_wf_cols)]:
                    st.markdown(f"**{_wcity}**")
                    _city_rows = _wf_df[_wf_df['City'] == _wcity]
                    for _, _wr in _city_rows.iterrows():
                        _risk = int(_wr.get('Rain_Risk_Pct', 0))
                        _impact = str(_wr.get('Delivery_Impact', 'Normal'))
                        _rain_time = str(_wr.get('Rain_Start_Time', 'N/A'))
                        _cond = str(_wr.get('Condition', ''))
                        _temp = _wr.get('Temp_C', '')

                        if _risk >= 70:
                            _flag = "üî¥"
                            _border = "#dc3545"
                            _bg     = "#fff5f5"
                            _time_note = f"<br><small>‚è∞ Rain from ~{_rain_time}</small>" if _rain_time != 'N/A' else ""
                        elif _risk >= 40:
                            _flag = "üü°"
                            _border = "#ffc107"
                            _bg     = "#fffbee"
                            _time_note = f"<br><small>‚è∞ Rain possible ~{_rain_time}</small>" if _rain_time != 'N/A' else ""
                        else:
                            _flag = "üü¢"
                            _border = "#28a745"
                            _bg     = "#f5fff5"
                            _time_note = ""

                        _impact_icon = {"Boost":"üìà","Normal":"‚û°Ô∏è","Risk":"‚ö†Ô∏è"}.get(_impact, "‚û°Ô∏è")

                        st.markdown(
                            f'<div style="border-left:3px solid {_border};background:{_bg};'
                            f'padding:6px 10px;border-radius:5px;margin:3px 0;font-size:12px;">'
                            f'<b>{_wr.get("Date","")}</b> &nbsp; {_flag} {_risk}% rain<br>'
                            f'üå°Ô∏è {_temp}¬∞C &nbsp;|&nbsp; {_cond}<br>'
                            f'{_impact_icon} {_impact}{_time_note}'
                            f'</div>',
                            unsafe_allow_html=True
                        )

            st.markdown("---")
            st.markdown(
                '<small>üî¥ ‚â•70% rain risk ‚Äî high delivery disruption risk &nbsp;|&nbsp; '
                'üü° 40‚Äì69% ‚Äî moderate risk &nbsp;|&nbsp; üü¢ &lt;40% ‚Äî normal operations &nbsp;|&nbsp; '
                'üìà Demand Boost &nbsp;|&nbsp; ‚ö†Ô∏è Operational Risk</small>',
                unsafe_allow_html=True
            )

            with st.expander("üìã Full forecast table", expanded=False):
                _disp_wf = _wf_df.copy()
                _disp_wf['Rain Alert'] = _disp_wf['Rain_Risk_Pct'].apply(
                    lambda x: "üî¥ HIGH RISK" if x >= 70 else ("üü° Moderate" if x >= 40 else "üü¢ Clear")
                )
                st.dataframe(_disp_wf, use_container_width=True)

            _wf_excel_buf = io.BytesIO()
            with pd.ExcelWriter(_wf_excel_buf, engine='xlsxwriter') as _wf_writer:
                _wf_df.to_excel(_wf_writer, sheet_name='7-Day Forecast', index=False)
                _wf_ws = _wf_writer.sheets['7-Day Forecast']
                _wf_wb2 = _wf_writer.book
                _hdr_fmt = _wf_wb2.add_format({'bold': True, 'bg_color': '#1f77b4', 'font_color': 'white', 'border': 1})
                _red_fmt = _wf_wb2.add_format({'bg_color': '#ffcccc', 'bold': True})
                _yel_fmt = _wf_wb2.add_format({'bg_color': '#fff3cd'})
                for _col_i, _col_name in enumerate(_wf_df.columns):
                    _wf_ws.write(0, _col_i, _col_name, _hdr_fmt)
                    _wf_ws.set_column(_col_i, _col_i, 18)
                for _ri, _row in _wf_df.iterrows():
                    _row_risk = int(_row.get('Rain_Risk_Pct', 0))
                    if _row_risk >= 70:
                        for _ci2 in range(len(_wf_df.columns)):
                            _wf_ws.write(_ri + 1, _ci2, _row.iloc[_ci2], _red_fmt)
                    elif _row_risk >= 40:
                        for _ci2 in range(len(_wf_df.columns)):
                            _wf_ws.write(_ri + 1, _ci2, _row.iloc[_ci2], _yel_fmt)
            st.download_button(
                "‚¨áÔ∏è Download Weather Forecast (Excel)",
                data=_wf_excel_buf.getvalue(),
                file_name=f"Tanzania_Weather_Forecast_{pd.Timestamp.today().strftime('%d_%b_%Y')}.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                key="dl_weather_excel"
            )
        else:
            _raw_text = st.session_state.get(_wf_data_key, "")
            if isinstance(_raw_text, str) and _raw_text:
                st.markdown(
                    f'<div class="ai-insight-card"><span class="ai-insight-label">üå§Ô∏è AI Weather Intelligence</span>'
                    f'{_raw_text}</div>',
                    unsafe_allow_html=True
                )
            else:
                st.info("Weather forecast could not be parsed. Please try generating again.")

        st.divider()

    # ‚îÄ‚îÄ Failed & Rejected Orders ‚îÄ‚îÄ
    st.markdown('<div class="section-header">‚ùå Failed & Rejected Orders Analysis</div>', unsafe_allow_html=True)

    if 'STATE' not in df.columns:
        st.info("STATE column not found.")
    else:
        failed_df   = df[df['STATE'] == 'Delivery Failed By Driver'].copy()
        rejected_df = df[df['STATE'].str.contains('Rejected|rejected', na=False)].copy()

        c1, c2 = st.columns(2)
        c1.metric("Total Failed (period)", len(failed_df),
                  delta=f"KPI ‚â§ {FAILED_KPI}/week",
                  delta_color="off")
        c2.metric("Total Rejected (period)", len(rejected_df))

        # Weekly trend chart
        def _weekly_state_trend(state_df, label, color, kpi_line=None):
            if state_df.empty:
                return None
            state_df = state_df.copy()
            state_df['ISO_Y'] = state_df['DELIVERY DATE'].dt.isocalendar().year
            state_df['ISO_W'] = state_df['DELIVERY DATE'].dt.isocalendar().week
            wk = (state_df.groupby(['ISO_Y','ISO_W']).size()
                  .reset_index(name=label))
            wk['Week_Label'] = (wk['ISO_Y'].astype(str)+"-W"+
                                wk['ISO_W'].astype(str).str.zfill(2))
            fig, ax = plt.subplots(figsize=(12, 4))
            ax.plot(wk['Week_Label'], wk[label], marker='o', color=color, lw=2, label=label)
            if kpi_line:
                ax.axhline(kpi_line, linestyle='--', color='orange', lw=2,
                           label=f'KPI ({kpi_line})')
            ax.set_xlabel("Week"); ax.set_ylabel("Count"); ax.grid(True, alpha=0.3)
            ax.legend(); plt.xticks(rotation=45, ha='right'); plt.tight_layout()
            return fig, wk

        if not failed_df.empty:
            result = _weekly_state_trend(failed_df, "Failed Orders", "#d62728", FAILED_KPI)
            if result:
                fig_f, failed_weekly = result
                st.pyplot(fig_f); plt.close()

                # Day √ó City pivot for selected week
                failed_weekly_wl = failed_weekly.copy()
                week_opts = failed_weekly_wl['Week_Label'].tolist()
                sel_week = st.selectbox("Select Week for Breakdown", week_opts,
                                        index=len(week_opts)-1, key="failed_week_sel")
                yr, wn = int(sel_week.split("-W")[0]), int(sel_week.split("-W")[1])
                w_start = pd.to_datetime(f"{yr}-W{wn}-1", format='%G-W%V-%u')
                w_end   = w_start + pd.Timedelta(days=6)
                wf      = failed_df[(failed_df['DELIVERY DATE'] >= w_start) &
                                    (failed_df['DELIVERY DATE'] <= w_end)].copy()
                wf['Day'] = wf['DELIVERY DATE'].dt.day_name()

                pivot = pd.pivot_table(wf, index='BUSINESS CITY', columns='Day',
                                       values='ID', aggfunc='count', fill_value=0)
                pivot = pivot.reindex(columns=DAY_NAMES, fill_value=0)
                pivot['Total'] = pivot.sum(axis=1)
                total_row = pivot.sum().to_frame().T; total_row.index = ['TOTAL']
                pivot = pd.concat([pivot, total_row])
                tot = int(pivot.loc['TOTAL','Total'])
                pivot['Status'] = ""
                pivot.loc['TOTAL','Status'] = (
                    "‚úÖ Within KPI" if tot <= FAILED_KPI
                    else f"‚ùå Over by {tot - FAILED_KPI}"
                )
                st.dataframe(pivot.style.set_properties(**{'text-align':'center'}),
                             use_container_width=True)
                st.download_button("‚¨áÔ∏è Download Failed Orders",
                                   data=excel_bytes(wf),
                                   file_name=f"failed_{sel_week}.xlsx",
                                   mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

                ai_insight_button("failed_orders", "Failed Orders", build_failed_insight, failed_weekly_wl, pivot, sel_week)

        if not rejected_df.empty:
            st.markdown("#### üö´ Rejected Orders Analysis")
            result_r = _weekly_state_trend(rejected_df, "Rejected Orders", "#9467bd")
            if result_r:
                fig_r, rej_weekly = result_r
                st.pyplot(fig_r); plt.close()

                # ‚îÄ‚îÄ City breakdown ‚îÄ‚îÄ
                _rej_city = (rejected_df.groupby('BUSINESS CITY')
                             .agg(Count=('ID','count'), Revenue_Lost=('SUBTOTAL','sum'))
                             .reset_index().sort_values('Count', ascending=False))
                _rej_city['Revenue_Lost'] = _rej_city['Revenue_Lost'].apply(lambda x: f"{int(x):,} TZS")
                _rej_city['% of Total'] = (_rej_city['Count'] / max(len(rejected_df),1) * 100).round(1)

                # ‚îÄ‚îÄ Top restaurants with repeated cancellations ‚îÄ‚îÄ
                _rej_biz = (rejected_df.groupby('BUSINESS NAME')
                            .agg(Rejections=('ID','count'), Revenue_Lost=('SUBTOTAL','sum'))
                            .reset_index().sort_values('Rejections', ascending=False).head(15))
                _total_lost = rejected_df['SUBTOTAL'].sum()

                # ‚îÄ‚îÄ Time of day pattern ‚îÄ‚îÄ
                _rej_hour = (rejected_df.groupby('HOUR').size().reset_index(name='Rejections')
                             if 'HOUR' in rejected_df.columns else pd.DataFrame())

                _rj1, _rj2 = st.columns(2)
                with _rj1:
                    st.markdown("##### üèôÔ∏è Rejected Orders by City")
                    st.dataframe(_rej_city, use_container_width=True)
                with _rj2:
                    st.markdown("##### üçΩÔ∏è Top Restaurants with Rejections")
                    _rej_biz_disp = _rej_biz.copy()
                    _rej_biz_disp['Revenue_Lost'] = _rej_biz_disp['Revenue_Lost'].apply(lambda x: f"{int(x):,} TZS")
                    st.dataframe(_rej_biz_disp, use_container_width=True)

                st.metric("üí∏ Total Revenue Lost to Rejections",
                          f"{_total_lost/1e6:.2f}M TZS",
                          delta=f"{len(rejected_df)} orders lost", delta_color="inverse")

                if not _rej_hour.empty:
                    fig_rh, ax_rh = plt.subplots(figsize=(12,4))
                    ax_rh.bar(_rej_hour['HOUR'].astype(str).apply(lambda h: f"{int(h):02d}:00"),
                              _rej_hour['Rejections'], color='#9467bd', alpha=0.8)
                    ax_rh.set_title("Rejected Orders by Hour of Day")
                    ax_rh.set_xlabel("Hour"); ax_rh.set_ylabel("Rejections")
                    ax_rh.grid(True, alpha=0.3, axis='y')
                    plt.xticks(rotation=45); plt.tight_layout()
                    st.pyplot(fig_rh); plt.close()

                # ‚îÄ‚îÄ AI insight ‚Äî auto-runs ‚îÄ‚îÄ
                _rej_ctx = (
                    f"REJECTED ORDERS ANALYSIS\n"
                    f"Total rejected: {len(rejected_df):,} | Revenue lost: {_total_lost/1e6:.2f}M TZS\n"
                    f"Rejection rate: {len(rejected_df)/max(len(df),1)*100:.1f}% of all orders\n\n"
                    f"BY CITY:\n{_rej_city.to_string(index=False)}\n\n"
                    f"TOP BUSINESSES BY REJECTIONS:\n{_rej_biz.head(10).to_string(index=False)}\n\n"
                    f"WEEKLY TREND:\n{rej_weekly[['Week_Label','Rejected Orders']].to_string(index=False)}"
                )
                _rej_prompt = (
                    "You are a senior operations analyst for Piki, a Tanzanian food delivery company.\n\n"
                    + _rej_ctx + "\n\n"
                    "Provide a deep rejected orders analysis:\n"
                    "1. **Rejection Trend** ‚Äî Is it improving or worsening week over week? Key inflection points.\n"
                    "2. **Worst Offenders** ‚Äî Which restaurants have the highest rejections? What might cause this (capacity, hours, system)?\n"
                    "3. **City Concentration** ‚Äî Which cities drive the most rejections? Is it proportional to their order volume?\n"
                    "4. **Revenue Impact** ‚Äî Quantify the financial loss. If this rate continues, what is the monthly revenue at risk?\n"
                    "5. **Time Pattern** ‚Äî Based on the hour data, when do rejections peak? What operational change does this suggest?\n"
                    "6. **Recommendations** ‚Äî 3 specific, actionable steps to reduce rejections by 30% within 2 weeks.\n"
                    "Use exact numbers. Be direct and operational."
                )
                _rej_ins_key = "rej_auto_insight"
                _rej_ctx_hash = str(hash(_rej_ctx[:200]))
                if _rej_ins_key not in st.session_state:
                    st.session_state[_rej_ins_key] = None
                    st.session_state[_rej_ins_key + "_h"] = None
                if (st.session_state[_rej_ins_key] is None or
                        st.session_state.get(_rej_ins_key + "_h") != _rej_ctx_hash):
                    with st.spinner("ü§ñ Analyzing rejected orders‚Ä¶"):
                        try:
                            st.session_state[_rej_ins_key] = claude_insight(_rej_prompt, 900)
                            st.session_state[_rej_ins_key + "_h"] = _rej_ctx_hash
                        except Exception as _re2:
                            st.session_state[_rej_ins_key] = f"Error: {_re2}"
                if st.session_state[_rej_ins_key]:
                    ai_block("rejected_orders", _rej_ctx, st.session_state[_rej_ins_key])
                _rj_rc1, _ = st.columns([2,4])
                if _rj_rc1.button("‚Ü∫ Refresh Rejection Insight", key="btn_rej_refresh"):
                    st.session_state[_rej_ins_key] = None
                    st.rerun()

        # PDF download
        st.divider()
        pdf_data = BytesIO()
        with PdfPages(pdf_data) as pdf:
            for city in sorted(df['BUSINESS CITY'].dropna().unique()):
                cdf = df[df['BUSINESS CITY'] == city]
                cw = (cdf.groupby(cdf['DELIVERY DATE'].dt.to_period('W-SUN'))
                      .agg(Total_Orders=('ID','count'), Total_Sales=('SUBTOTAL','sum'))
                      .reset_index())
                cw['Week'] = cw['DELIVERY DATE'].dt.start_time
                cw['Week_Label'] = cw['DELIVERY DATE'].apply(
                    lambda p: f"W{p.week}")
                cw = apply_growth_kpi(cw)
                fig_p, ax_p1 = plt.subplots(figsize=(10, 5))
                ax_p1.plot(cw['Week_Label'], cw['Total_Orders'], marker='o', label='Orders')
                if 'Growth KPI Orders' in cw.columns:
                    ax_p1.plot(cw['Week_Label'], cw['Growth KPI Orders'],
                               linestyle='--', color='green', label='KPI')
                ax_p1.set_ylabel("Orders"); ax_p1.grid(True)
                ax_p2 = ax_p1.twinx()
                ax_p2.plot(cw['Week_Label'], cw['Total_Sales'],
                           color='orange', marker='o', label='Sales')
                ax_p2.yaxis.set_major_formatter(fmt_millions)
                ax_p2.set_ylabel("Sales (TZS)")
                plt.title(f"KPI Trend ‚Äî {city}"); fig_p.legend(loc='upper left')
                plt.tight_layout(); pdf.savefig(fig_p); plt.close()

        st.download_button("üì• Download All Cities KPI PDF",
                           data=pdf_data.getvalue(),
                           file_name="Weekly_KPI_All_Cities.pdf",
                           mime="application/pdf")


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TAB 2 ‚Äî DELIVERY TIMES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
with tab2:
    st.markdown('<div class="section-header">‚è∞ Delivery Time Analysis</div>', unsafe_allow_html=True)

    df2 = compute_delivery_stages(df)
    df2 = add_distance(df2)
    df2['ISO_Week'] = df2['DELIVERY DATE'].dt.isocalendar().week
    df2['ISO_Year'] = df2['DELIVERY DATE'].dt.isocalendar().year

    # ‚îÄ‚îÄ Week selector ‚Äî default latest week ‚îÄ‚îÄ
    _wk_grp = (df2.groupby(['ISO_Year','ISO_Week']).size().reset_index()[['ISO_Year','ISO_Week']]
               .sort_values(['ISO_Year','ISO_Week']))
    _wk_grp['Label'] = (_wk_grp['ISO_Year'].astype(str) + "-W"
                         + _wk_grp['ISO_Week'].astype(str).str.zfill(2))
    del_week_labels = _wk_grp['Label'].tolist()
    sel_del_week = st.selectbox("üìÖ Select Week (KPI metrics & table, default = latest)",
                                del_week_labels, index=len(del_week_labels)-1, key="del_week_sel")
    _yr = int(sel_del_week.split("-W")[0]); _wn = int(sel_del_week.split("-W")[1])
    df2_week = df2[(df2['ISO_Year']==_yr) & (df2['ISO_Week']==_wn)]

    # ‚îÄ‚îÄ KPI metrics ‚Äî selected week, completed only, OUTLIERS EXCLUDED ‚îÄ‚îÄ
    def _filter_clean_completed(frame):
        """Return only completed orders with all stages within valid operational ranges.
        Excludes outliers that inflate average delivery time.
        """
        _fc = (frame[frame["STATE"].isin(["Delivery Completed By Driver","Completed"])].copy()
               if "STATE" in frame.columns else frame.copy())
        _stage_limits = {
            "Accepted by Business": (0, 30),
            "Assigned Time":        (0, 30),
            "Accepted by Driver":   (0, 45),
            "Driver to Business":   (0, 45),
            "Driver in Business":   (0, 90),
            "Pickup to Customer":   (0, 45),
            "Average Delivery Time":(0,100),
        }
        for _fcol, (_lo, _hi) in _stage_limits.items():
            if _fcol in _fc.columns:
                _fc = _fc[(_fc[_fcol] >= _lo) & (_fc[_fcol] <= _hi)]
        return _fc

    _comp = _filter_clean_completed(df2_week)
    avg_adt = _comp["Average Delivery Time"].mean() if not _comp.empty else 0
    avg_dib = _comp["Driver in Business"].mean()    if not _comp.empty else 0
    avg_p2c = _comp["Pickup to Customer"].mean()    if not _comp.empty else 0
    avg_abb = _comp["Accepted by Business"].mean()  if not _comp.empty else 0

    mc1, mc2, mc3, mc4 = st.columns(4)
    mc1.metric("‚è± Avg Delivery Time",    f"{avg_adt:.1f} min",
               delta="Target < 45 min",  delta_color=("normal" if avg_adt < 45 else "inverse"))
    mc2.metric("üç≥ Vendor Prep Time",    f"{avg_dib:.1f} min",
               delta="Target < 20 min",  delta_color=("normal" if avg_dib < 20 else "inverse"))
    mc3.metric("üõµ Pickup‚ÜíCustomer",     f"{avg_p2c:.1f} min")
    mc4.metric("‚úÖ Business Acceptance", f"{avg_abb:.1f} min")

    # ‚îÄ‚îÄ Stage table ‚Äî selected week only ‚îÄ‚îÄ
    st.subheader(f"üìä Delivery Stage Avg by City ‚Äî {sel_del_week}")
    stage_cols = ['Accepted by Business','Assigned Time','Accepted by Driver',
                  'Driver to Business','Driver in Business','Pickup to Customer',
                  'Average Delivery Time']
    # City stage averages from clean completed orders only
    city_stage = (_comp.groupby("BUSINESS CITY")[stage_cols]
                  .mean().round(1).reset_index()
                  .sort_values("Average Delivery Time", ascending=True))
    st.download_button("‚¨áÔ∏è Download Delivery Table",
                       data=city_stage.to_csv(index=False).encode(),
                       file_name=f"delivery_{sel_del_week}.csv", mime="text/csv")

    # ‚îÄ‚îÄ Hourly chart ‚îÄ‚îÄ
    st.subheader("üìà Hourly Delivery Time vs Volume")
    df2['HOUR'] = df2['DELIVERY TIME'].dt.hour
    # Hourly: use clean completed orders only
    _df2_clean = _filter_clean_completed(df2)
    hourly = (_df2_clean[_df2_clean['HOUR'].isin(OPERATING_HOURS)]
              .groupby('HOUR')
              .agg(avg_dt=('Average Delivery Time','mean'), orders=('ID','count'))
              .reset_index())
    hourly['order_idx'] = hourly['HOUR'].apply(lambda h: OPERATING_HOURS.index(h))
    hourly = hourly.sort_values('order_idx')
    hourly['Label'] = hourly['HOUR'].apply(lambda h: f"{h:02d}:00")

    fig_h, ax_h1 = plt.subplots(figsize=(13, 5))
    ax_h2 = ax_h1.twinx()
    ax_h2.bar(hourly['Label'], hourly['orders'], alpha=0.25, color='steelblue', label='Orders')
    ax_h1.plot(hourly['Label'], hourly['avg_dt'], marker='o', color='red', lw=2, label='Avg Delivery Time')
    ax_h1.set_ylabel("Avg Delivery Time (min)"); ax_h2.set_ylabel("Order Volume")
    ax_h1.set_xlabel("Hour"); ax_h1.grid(True, alpha=0.3)
    h1l, h1lb = ax_h1.get_legend_handles_labels(); h2l, h2lb = ax_h2.get_legend_handles_labels()
    ax_h1.legend(h1l+h2l, h1lb+h2lb, loc='upper right')
    plt.title("Hourly Delivery Time vs Volume"); plt.xticks(rotation=90); plt.tight_layout()
    st.pyplot(fig_h); plt.close()

    # ‚îÄ‚îÄ Area charts (Dar vs Regional) ‚îÄ‚îÄ
    st.subheader("üìç Area Performance Charts")
    for area_name, cities in [("üèôÔ∏è Dar es Salaam", DAR_CITIES), ("üåç Regional", REGIONAL_CITIES)]:
        with st.expander(area_name):
            df_area = df2[df2['BUSINESS CITY'].isin(cities)]
            if df_area.empty:
                st.info("No data for this area in current filter.")
                continue
            for metric, title in [
                ('Average Delivery Time', 'Avg Delivery Time'),
                ('Driver in Business',    'Vendor Prep Time'),
                ('Pickup to Customer',    'Pickup ‚Üí Customer'),
            ]:
                fig_a, ax_a = plt.subplots(figsize=(10, 4))
                for city in cities:
                    cdf = df_area[df_area['BUSINESS CITY']==city]
                    if cdf.empty: continue
                    wk = (cdf.groupby(cdf['DELIVERY DATE'].dt.to_period('W-SUN'))[metric]
                          .mean().reset_index())
                    wk.columns = ['Period', metric]
                    wk = wk.sort_values('Period')
                    wk['Label'] = [f"W{i+1}" for i in range(len(wk))]
                    ax_a.plot(wk['Label'], wk[metric], marker='o', label=city)
                ax_a.set_title(f"{title} ‚Äî {area_name}")
                ax_a.set_ylabel("Minutes"); ax_a.grid(True, alpha=0.3); ax_a.legend()
                plt.tight_layout(); st.pyplot(fig_a); plt.close()

    # AI insight
    ai_insight_button("delivery_time", "Delivery Time Analysis", build_delivery_insight, city_stage, city_label)

    st.divider()

    # ‚îÄ‚îÄ Heatmap ‚îÄ‚îÄ
    st.subheader("üó∫Ô∏è Customer & Business Location Heatmap")
    req_geo = ['CUSTOMER LATITUDE','CUSTOMER LONGITUDE','BUSINESS LATITUDE','BUSINESS LONGITUDE']
    if all(c in df2.columns for c in req_geo):
        geo = df2.dropna(subset=req_geo)
        if not geo.empty:
            map_type = st.radio("Map View",
                ["Both","Customer Only","Business Only"], horizontal=True, key="del_map")
            center = ([geo['CUSTOMER LATITUDE'].mean(), geo['CUSTOMER LONGITUDE'].mean()]
                      if city_sel else [-6.8018, 39.2801])
            m = folium.Map(location=center, zoom_start=13)
            if map_type != "Business Only":
                HeatMap(geo[['CUSTOMER LATITUDE','CUSTOMER LONGITUDE']].values.tolist(),
                        radius=12, blur=10).add_to(m)
            if map_type != "Customer Only":
                HeatMap(geo[['BUSINESS LATITUDE','BUSINESS LONGITUDE']].values.tolist(),
                        radius=15, blur=12).add_to(m)
            folium.LayerControl().add_to(m)

            top_n_del = st.slider("Top restaurants on map", 5, 30, 10, key="del_top_n")
            rp = (geo.groupby(['BUSINESS NAME','BUSINESS LATITUDE','BUSINESS LONGITUDE'])
                  .agg(Orders=('ID','count'), Sales=('SUBTOTAL','sum'),
                       AvgDT=('Average Delivery Time','mean'))
                  .reset_index().sort_values('Orders', ascending=False))
            for _, r in rp.head(top_n_del).iterrows():
                folium.CircleMarker(
                    [r['BUSINESS LATITUDE'], r['BUSINESS LONGITUDE']],
                    radius=7, color='navy', fill=True, fill_opacity=0.8,
                    popup=f"<b>{r['BUSINESS NAME']}</b><br>Orders: {int(r['Orders'])}<br>"
                          f"Avg DT: {r['AvgDT']:.1f} min"
                ).add_to(m)
            st.components.v1.html(m._repr_html_(), height=500)
    else:
        st.info("Geo columns not found.")

    # PDF report
    st.divider()
    if st.button("üñ®Ô∏è Generate Delivery PDF Report"):
        pdf_d = BytesIO()
        with PdfPages(pdf_d) as pdf:
            plt.figure(figsize=(11,8)); plt.axis('off')
            plt.text(0.5,0.6,"Piki Delivery Performance Report",fontsize=24,ha='center')
            plt.text(0.5,0.45,f"{date_range[0]} ‚Üí {date_range[1]}",fontsize=14,ha='center')
            pdf.savefig(); plt.close()
            for area_name, cities in [("Dar es Salaam", DAR_CITIES), ("Regional", REGIONAL_CITIES)]:
                for metric, title in [
                    ('Average Delivery Time','Avg Delivery Time'),
                    ('Driver in Business','Vendor Prep Time'),
                    ('Pickup to Customer','Pickup‚ÜíCustomer'),
                ]:
                    plt.figure(figsize=(10,5))
                    for city in cities:
                        cdf = df2[df2['BUSINESS CITY']==city]
                        if cdf.empty: continue
                        wk = cdf.groupby(cdf['DELIVERY DATE'].dt.to_period('W-SUN'))[metric].mean().reset_index()
                        wk.columns = ['P', metric]; wk = wk.sort_values('P')
                        plt.plot([f"W{i+1}" for i in range(len(wk))], wk[metric], marker='o', label=city)
                    plt.title(f"{title} ‚Äî {area_name}"); plt.ylabel("Min"); plt.legend(); plt.grid(True)
                    pdf.savefig(); plt.close()
        st.download_button("üì• Download Delivery PDF",
                           data=pdf_d.getvalue(),
                           file_name="Delivery_Performance_Report.pdf",
                           mime="application/pdf")


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TAB 3 ‚Äî RIDER ATTENDANCE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
with tab3:
    st.markdown('<div class="section-header">üö¥ Driver Attendance & Analysis</div>', unsafe_allow_html=True)

    df3 = df.copy()
    df3['DELIVERY DATE'] = pd.to_datetime(df3['DELIVERY DATE'], errors='coerce')

    # Zone map from full raw dataset for accuracy
    _zone_src = raw.copy()
    _zone_src['DELIVERY DATE'] = pd.to_datetime(_zone_src['DELIVERY DATE'], errors='coerce')
    zone_map = (_zone_src.groupby('DRIVER NAME')['BUSINESS CITY']
                .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else None))
    df3['WORKING ZONE'] = df3['DRIVER NAME'].map(zone_map)
    df3['ISO_Week'] = df3['DELIVERY DATE'].dt.isocalendar().week
    df3['ISO_Year'] = df3['DELIVERY DATE'].dt.isocalendar().year
    df3['Day of Week'] = df3['DELIVERY DATE'].dt.day_name()

    # ‚îÄ‚îÄ Week selector ‚Äî default latest ‚îÄ‚îÄ
    _att_wk = (df3.groupby(['ISO_Year','ISO_Week']).size().reset_index()[['ISO_Year','ISO_Week']]
               .sort_values(['ISO_Year','ISO_Week']))
    _att_wk['Label'] = (_att_wk['ISO_Year'].astype(str) + "-W"
                        + _att_wk['ISO_Week'].astype(str).str.zfill(2))
    att_labels = _att_wk['Label'].tolist()
    sel_week_att = st.selectbox("üìÖ Select ISO Week (default = latest)",
                                att_labels, index=len(att_labels)-1, key="att_week")
    _ayr = int(sel_week_att.split("-W")[0]); _awn = int(sel_week_att.split("-W")[1])
    df_week = df3[(df3['ISO_Year']==_ayr) & (df3['ISO_Week']==_awn)]

    # ‚îÄ‚îÄ Build attendance pivot ‚îÄ‚îÄ
    pivot_rows = []
    for _, tr in TARGET_RIDERS.iterrows():
        city = tr['Business City']
        row  = {'WORKING ZONE': city}
        city_df = df_week[df_week['WORKING ZONE'] == city]
        deficits, surplus = [], []
        for day in DAY_NAMES:
            dtype  = 'Weekend' if day in ['Saturday','Sunday'] else 'Weekday'
            std    = tr[f'{dtype} Active Riders']
            actual = city_df[city_df['Day of Week']==day]['DRIVER NAME'].nunique()
            row[day] = f"‚úÖ {actual}" if actual >= std else f"‚ö†Ô∏è {actual}/{std}"
            if actual < std:
                deficits.append(std - actual)
            else:
                surplus.append(actual - std)
        row['Avg Deficiency'] = round(sum(deficits)/len(deficits), 1) if deficits else 0.0
        row['Avg Surplus']    = round(sum(surplus)/len(surplus), 1)   if surplus  else 0.0
        row['Status'] = (f"‚ûï Add {int(round(sum(deficits)/len(deficits)))} rider(s)"
                         if deficits else "‚úÖ Sufficient")
        pivot_rows.append(row)

    att_pivot = pd.DataFrame(pivot_rows)

    # ‚îÄ‚îÄ 4 summary KPI metrics ‚îÄ‚îÄ
    n_deficient = len(att_pivot[att_pivot['Avg Deficiency'] > 0])
    n_ok        = len(att_pivot) - n_deficient
    worst_city  = (att_pivot.nlargest(1, 'Avg Deficiency')['WORKING ZONE'].values[0]
                   if n_deficient else "‚Äî")
    _ok_zones   = att_pivot[att_pivot['Avg Deficiency'] == 0]
    best_city   = (_ok_zones.nlargest(1, 'Avg Surplus')['WORKING ZONE'].values[0]
                   if not _ok_zones.empty else "‚Äî")

    _a1, _a2, _a3, _a4 = st.columns(4)
    _a1.metric("‚úÖ Cities at Target",    n_ok)
    _a2.metric("‚ö†Ô∏è Cities Understaffed", n_deficient)
    _a3.metric("üî¥ Worst Zone",          worst_city)
    _a4.metric("üü¢ Best Zone",           best_city)

    # Show pivot without surplus column for clean display
    _disp_cols = ['WORKING ZONE'] + DAY_NAMES + ['Avg Deficiency','Status']
    st.dataframe(att_pivot[_disp_cols], use_container_width=True)
    st.download_button("‚¨áÔ∏è Download Attendance Report",
                       data=excel_bytes(att_pivot, "Attendance"),
                       file_name=f"attendance_{sel_week_att}.xlsx",
                       mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

    # ‚îÄ‚îÄ Per-zone individual charts ‚îÄ‚îÄ
    st.subheader("üìä Daily Active Drivers by Zone")
    daily_drivers = (df_week.groupby(['WORKING ZONE','Day of Week'])['DRIVER NAME']
                     .nunique().reset_index(name='Active Drivers'))
    daily_drivers['Day of Week'] = pd.Categorical(daily_drivers['Day of Week'],
                                                   categories=DAY_NAMES, ordered=True)
    daily_drivers = daily_drivers.sort_values(['WORKING ZONE','Day of Week'])

    for group_name, group_cities in [("üèôÔ∏è Dar es Salaam", DAR_CITIES),
                                      ("üåç Regional", REGIONAL_CITIES)]:
        active_zones = [z for z in group_cities
                        if z in daily_drivers['WORKING ZONE'].values or
                           z in att_pivot['WORKING ZONE'].values]
        if not active_zones:
            continue
        st.markdown(f"#### {group_name}")
        # 2 charts per row
        for i in range(0, len(active_zones), 2):
            _cols = st.columns(2)
            for j, zone in enumerate(active_zones[i:i+2]):
                _zd = (daily_drivers[daily_drivers['WORKING ZONE']==zone]
                       .set_index('Day of Week').reindex(DAY_NAMES))
                _tr = TARGET_RIDERS[TARGET_RIDERS['Business City']==zone]
                if _tr.empty:
                    continue
                _wt = int(_tr['Weekday Active Riders'].values[0])
                _wet = int(_tr['Weekend Active Riders'].values[0])
                _targets = [_wet if d in ['Saturday','Sunday'] else _wt for d in DAY_NAMES]
                _actual  = _zd['Active Drivers'].fillna(0).values

                with _cols[j]:
                    fig_z, ax_z = plt.subplots(figsize=(6, 3.5))
                    _colors = ['#28a745' if a >= t else '#dc3545'
                               for a, t in zip(_actual, _targets)]
                    ax_z.bar(DAY_NAMES, _actual, color=_colors, alpha=0.8, label='Actual')
                    ax_z.step(range(len(DAY_NAMES)), _targets, where='mid',
                              color='black', linestyle='--', lw=1.5, label='Target')
                    ax_z.set_title(zone, fontsize=11, fontweight='bold')
                    ax_z.set_ylabel("Drivers"); ax_z.set_ylim(bottom=0)
                    ax_z.set_xticklabels([d[:3] for d in DAY_NAMES], fontsize=8)
                    ax_z.legend(fontsize=7); ax_z.grid(True, alpha=0.2, axis='y')
                    plt.tight_layout()
                    st.pyplot(fig_z); plt.close()

    # ‚îÄ‚îÄ AI Insight ‚Äî Attendance ‚îÄ‚îÄ
    _att_btn_key = "show_ins_rider_attendance"
    if _att_btn_key not in st.session_state:
        st.session_state[_att_btn_key] = False
    st.markdown(
        '''<div style="margin:12px 0 4px 0;">
        <span style="font-size:12px;color:#888;">AI-powered analysis of attendance patterns & KPI gaps</span>
        </div>''', unsafe_allow_html=True)
    if st.button("ü§ñ Generate AI Insight ‚Äî Attendance", key="btn_rider_att",
                 type="primary", use_container_width=False):
        st.session_state[_att_btn_key] = True
    if st.session_state[_att_btn_key]:
        with st.spinner("Analyzing attendance‚Ä¶"):
            ins3, ctx3 = build_attendance_insight(att_pivot, sel_week_att, df_week)
        ai_block("rider_attendance", ctx3, ins3)

    st.divider()

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # DRIVER PERFORMANCE REVIEW ‚Äî Last 8 Weeks
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    st.markdown('<div class="section-header">üèÜ Driver Performance Review ‚Äî Last 8 Weeks</div>', unsafe_allow_html=True)

    # ‚îÄ‚îÄ Compute delivery stage metrics for completed orders ‚îÄ‚îÄ
    _dr_df = raw.copy()
    _dr_df['DELIVERY DATE'] = pd.to_datetime(_dr_df['DELIVERY DATE'], errors='coerce')
    _dr_df['Week'] = _dr_df['DELIVERY DATE'].dt.to_period('W-SUN').apply(lambda r: r.start_time)
    _dr_df = compute_delivery_stages(_dr_df)

    # Working zone map
    _dr_zone = (_dr_df.groupby('DRIVER NAME')['BUSINESS CITY']
                .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else "Unknown"))

    # ‚îÄ‚îÄ‚îÄ Section A: Attendance ‚Äî last 8 weeks ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    st.markdown("### üìÖ A. Weekly Attendance (Last 8 Weeks)")
    _weekdays_order = ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday']
    _recent_8_weeks = _dr_df['Week'].drop_duplicates().sort_values(ascending=False).head(8)

    _all_att = []
    for _wk in _recent_8_weeks:
        _wk_data = _dr_df[_dr_df['Week'] == _wk]
        _iso_w = int(_wk.isocalendar()[1])
        _wk_label = f"W{_iso_w}"
        _pivot = pd.pivot_table(_wk_data, values='ID', index='DRIVER NAME',
                                columns=_wk_data['DELIVERY DATE'].dt.day_name(),
                                aggfunc='count', fill_value=0)
        _pivot = _pivot.reindex(columns=_weekdays_order, fill_value=0)
        _pivot = _pivot.applymap(lambda x: '‚úî' if x > 0 else '‚Äî')
        _pivot['Days'] = (_pivot == '‚úî').sum(axis=1)
        _pivot['Orders'] = _wk_data.groupby('DRIVER NAME')['ID'].count()
        _pivot['Week'] = _wk_label
        _pivot = _pivot.reset_index()
        _all_att.append(_pivot)

    if _all_att:
        _att_all = pd.concat(_all_att, ignore_index=True)
        _att_all['Working Zone'] = _att_all['DRIVER NAME'].map(_dr_zone)
        _att_cols = ['Week','DRIVER NAME','Working Zone'] + _weekdays_order + ['Days','Orders']
        _att_all = _att_all[[c for c in _att_cols if c in _att_all.columns]]

        # Filter by zone
        _perf_zones = sorted(_att_all['Working Zone'].dropna().unique())
        _zone_filter = st.multiselect("Filter by Working Zone", _perf_zones,
                                      placeholder="All zones", key="dr_zone_filter")
        _att_show = _att_all[_att_all['Working Zone'].isin(_zone_filter)] if _zone_filter else _att_all

        # Color-code rows: many days = green, few days = red
        def _style_att(v):
            if v == '‚úî': return 'background-color:#d4edda;color:#155724'
            if v == '‚Äî':  return 'background-color:#fff3cd;color:#856404'
            return ''

        st.dataframe(_att_show.style.applymap(_style_att,
                     subset=[c for c in _weekdays_order if c in _att_show.columns]),
                     use_container_width=True, height=400)
        st.download_button("‚¨áÔ∏è Download Attendance (8 weeks)",
                           data=excel_bytes(_att_all, "Attendance"),
                           file_name="Driver_Attendance_8W.xlsx",
                           mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

        # ‚îÄ‚îÄ Visualisations ‚îÄ‚îÄ
        _v1, _v2, _v3 = st.columns(3)
        with _v1:
            st.markdown("**Days worked distribution**")
            _days_dist = _att_all.groupby('DRIVER NAME')['Days'].mean().round(1)
            _fd, _ad = plt.subplots(figsize=(5,3))
            _days_dist.value_counts().sort_index().plot(kind='bar', ax=_ad,
                color='#4d96ff', edgecolor='white')
            _ad.set_xlabel("Avg days/week"); _ad.set_ylabel("# Drivers")
            _ad.set_title("Days Worked Distribution"); plt.tight_layout()
            st.pyplot(_fd); plt.close()

        with _v2:
            st.markdown("**Attendance rate by day**")
            _day_rate = _att_all[[d for d in _weekdays_order if d in _att_all.columns]].apply(
                lambda col: (col=='‚úî').sum() / len(col) * 100)
            _fr, _ar = plt.subplots(figsize=(5,3))
            _day_rate.plot(kind='bar', ax=_ar, color=['#28a745' if v>=60 else '#dc3545' for v in _day_rate])
            _ar.set_ylabel("Attendance %"); _ar.set_ylim(0,100)
            _ar.set_title("Attendance Rate by Day")
            _ar.set_xticklabels([d[:3] for d in _day_rate.index], rotation=0)
            plt.tight_layout(); st.pyplot(_fr); plt.close()

        with _v3:
            st.markdown("**Worked vs Missed (overall)**")
            _total_worked = (_att_all[[d for d in _weekdays_order if d in _att_all.columns]] == '‚úî').values.sum()
            _total_missed = (_att_all[[d for d in _weekdays_order if d in _att_all.columns]] == '‚Äî').values.sum()
            _fp, _ap = plt.subplots(figsize=(4,3))
            _ap.pie([_total_worked, _total_missed], labels=['Worked','Missed'],
                    colors=['#28a745','#ffc107'], autopct='%1.0f%%',
                    startangle=90, wedgeprops={'edgecolor':'white','lw':2})
            _ap.set_title("Overall Attendance"); plt.tight_layout()
            st.pyplot(_fp); plt.close()

    # ‚îÄ‚îÄ‚îÄ Section B: KPI Performance ‚Äî last 8 weeks ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    st.markdown("### üìä B. Driver KPI Performance (Last 8 Weeks)")
    st.caption("Only clean completed deliveries used for time KPIs (outliers excluded).")

    _dr_comp = _dr_df[_dr_df['STATE'].isin(['Delivery Completed By Driver','Completed'])].copy()

    def _cat_issues(row):
        checks = [('Accepted by Business',30),('Assigned Time',30),('Accepted by Driver',45),
                  ('Driver to Business',45),('Driver in Business',90),('Pickup to Customer',45),
                  ('Average Delivery Time',100)]
        return ", ".join(c for c,l in checks
                         if pd.isnull(row.get(c,0)) or row.get(c,0) < 0 or row.get(c,0) > l)

    _dr_comp['Issues'] = _dr_comp.apply(_cat_issues, axis=1)
    _dr_comp_clean = _dr_comp[_dr_comp['Issues'] == ''].copy()

    _recent_8_kpi = _dr_comp_clean['Week'].drop_duplicates().sort_values(ascending=False).head(8)
    _all_kpis = []

    def _iso_w(ts):
        ic = ts.isocalendar()
        return ic.week if hasattr(ic,'week') else ic[1]

    for _wk in _recent_8_kpi:
        _wk_data = _dr_comp_clean[_dr_comp_clean['Week'] == _wk].copy()
        if 'DISTANCE (km)' not in _wk_data.columns: _wk_data['DISTANCE (km)'] = 0.0
        _kpi = _wk_data.groupby('DRIVER NAME').agg(
            Avg_DT=('Average Delivery Time','mean'),
            Accepted_Biz=('Accepted by Business','mean'),
            Assigned_T=('Assigned Time','mean'),
            Accepted_Drv=('Accepted by Driver','mean'),
            Drv_to_Biz=('Driver to Business','mean'),
            Drv_in_Biz=('Driver in Business','mean'),
            Pickup_Cust=('Pickup to Customer','mean'),
            Total_Orders=('ID','count'),
            Total_KM=('DISTANCE (km)','sum'),
            Avg_KM=('DISTANCE (km)','mean')
        ).round(1).reset_index()
        _kpi.columns = ['DRIVER NAME','Avg DT (min)','Accepted by Biz','Assigned Time',
                        'Accepted by Driver','Driver‚ÜíBusiness','Driver in Biz','Pickup‚ÜíCustomer',
                        'Total Orders','Total KM','Avg KM/Order']
        _kpi['Week'] = f"W{int(_iso_w(_wk))}"; _kpi['Working Zone'] = _kpi['DRIVER NAME'].map(_dr_zone)
        _all_kpis.append(_kpi)

    _kpi_all = pd.DataFrame()
    if _all_kpis:
        _kpi_all = pd.concat(_all_kpis, ignore_index=True)
        _kpi_all = _kpi_all[['Week','DRIVER NAME','Working Zone','Total Orders',
                              'Avg DT (min)','Accepted by Biz','Assigned Time','Accepted by Driver',
                              'Driver‚ÜíBusiness','Driver in Biz','Pickup‚ÜíCustomer','Total KM','Avg KM/Order']]

        # Sort most-recent week first per driver
        _kpi_all['_wn'] = _kpi_all['Week'].str.extract(r'(\d+)').astype(int)
        _kpi_all = _kpi_all.sort_values(['DRIVER NAME','_wn'], ascending=[True,False]).drop(columns='_wn')

        _kpi_zone_f = st.multiselect("Filter by Working Zone (KPI table)", _perf_zones,
                                      placeholder="All zones", key="kpi_zone_filter")
        _kpi_show = _kpi_all[_kpi_all['Working Zone'].isin(_kpi_zone_f)] if _kpi_zone_f else _kpi_all

        # Color-code DT column
        def _color_dt(v):
            try:
                f = float(v)
                if f <= 40: return 'background-color:#d4edda;color:#155724'
                if f <= 55: return 'background-color:#fff3cd;color:#856404'
                return 'background-color:#f8d7da;color:#721c24'
            except: return ''

        st.dataframe(_kpi_show.style.applymap(_color_dt, subset=['Avg DT (min)']),
                     use_container_width=True, height=440)
        st.download_button("‚¨áÔ∏è Download Driver KPIs (8 weeks)",
                           data=excel_bytes(_kpi_all, "Driver KPIs"),
                           file_name="Driver_KPIs_8W.xlsx",
                           mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

        # ‚îÄ‚îÄ Top / Bottom performers visual ‚îÄ‚îÄ
        st.markdown("#### üèÖ Top & Bottom Performers (8-Week Average Delivery Time)")
        _perf_sum = (_kpi_all.groupby(['DRIVER NAME','Working Zone'])['Avg DT (min)']
                     .mean().round(1).reset_index()
                     .rename(columns={'Avg DT (min)':'8W Avg DT (min)'})
                     .sort_values('8W Avg DT (min)'))
        _pg1, _pg2 = st.columns(2)
        with _pg1:
            st.markdown("üü¢ **Top 10 Fastest Riders**")
            _top10 = _perf_sum.head(10)
            _ftop, _atop = plt.subplots(figsize=(6,3.5))
            _bars_top = _atop.barh(_top10['DRIVER NAME'], _top10['8W Avg DT (min)'], color='#28a745')
            _atop.bar_label(_bars_top, fmt='%.1f', padding=3, fontsize=8)
            _atop.axvline(45, color='green', lw=1.5, linestyle='--', label='Target')
            _atop.set_xlabel("Avg DT (min)"); _atop.invert_yaxis()
            _atop.set_title("Fastest Riders"); _atop.legend(fontsize=7); plt.tight_layout()
            st.pyplot(_ftop); plt.close()
            st.dataframe(_top10[['DRIVER NAME','Working Zone','8W Avg DT (min)']],
                         use_container_width=True)
        with _pg2:
            st.markdown("üî¥ **Bottom 10 ‚Äî Need Coaching**")
            _bot10 = _perf_sum.tail(10).sort_values('8W Avg DT (min)', ascending=False)
            _fbot, _abot = plt.subplots(figsize=(6,3.5))
            _bars_bot = _abot.barh(_bot10['DRIVER NAME'], _bot10['8W Avg DT (min)'], color='#dc3545')
            _abot.bar_label(_bars_bot, fmt='%.1f', padding=3, fontsize=8)
            _abot.axvline(55, color='red', lw=1.5, linestyle=':', label='Alert')
            _abot.set_xlabel("Avg DT (min)"); _abot.invert_yaxis()
            _abot.set_title("Needs Coaching"); _abot.legend(fontsize=7); plt.tight_layout()
            st.pyplot(_fbot); plt.close()
            st.dataframe(_bot10[['DRIVER NAME','Working Zone','8W Avg DT (min)']],
                         use_container_width=True)

        # ‚îÄ‚îÄ Weekly trend: top 10 by volume ‚îÄ‚îÄ
        st.markdown("#### üìà Delivery Time Trend ‚Äî Top 10 Riders by Volume")
        _top_vol = _kpi_all.groupby('DRIVER NAME')['Total Orders'].sum().nlargest(10).index.tolist()
        _td = _kpi_all[_kpi_all['DRIVER NAME'].isin(_top_vol)]
        _fig_tr, _ax_tr = plt.subplots(figsize=(13,5))
        for _rn in _top_vol:
            _rd = _td[_td['DRIVER NAME']==_rn].sort_values('Week')
            if _rd.empty: continue
            _ax_tr.plot(_rd['Week'], _rd['Avg DT (min)'], marker='o', lw=1.5, label=_rn)
        _ax_tr.axhline(45, color='green', lw=2, linestyle='--', label='Target (45 min)')
        _ax_tr.axhline(55, color='red', lw=1.5, linestyle=':', label='Alert (55 min)')
        _ax_tr.fill_between(range(len(_kpi_all['Week'].unique())), 0, 45, alpha=0.05, color='green')
        _ax_tr.set_xlabel("Week"); _ax_tr.set_ylabel("Avg DT (min)")
        _ax_tr.set_title("Weekly Delivery Time Trend ‚Äî Top 10 by Volume")
        _ax_tr.legend(fontsize=7, ncol=4); _ax_tr.grid(True, alpha=0.3)
        plt.tight_layout(); st.pyplot(_fig_tr); plt.close()

    # ‚îÄ‚îÄ‚îÄ Section C: Regional Bonus Calculator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    st.markdown("### üí∞ C. Regional Rider Bonus Calculator")
    st.caption("Calculates bonus eligibility based on order volume vs city average and delivery time (target < 50 min)")

    _BONUS = 15000
    _regional_df = raw.copy()
    _regional_df['DELIVERY DATE'] = pd.to_datetime(_regional_df['DELIVERY DATE'], errors='coerce')
    _regional_df['Week'] = _regional_df['DELIVERY DATE'].dt.to_period('W-SUN').apply(lambda r: r.start_time)

    _bonus_comp = compute_delivery_stages(_regional_df)
    _bonus_comp = _bonus_comp[_bonus_comp['STATE'].isin(['Delivery Completed By Driver','Completed'])].copy()

    # Bonus week selector
    _bonus_weeks_avail = sorted(_bonus_comp['Week'].dropna().unique(), reverse=True)
    _bonus_week_opts   = [str(w.date()) for w in _bonus_weeks_avail]
    _sel_bonus_week_str = st.selectbox("Select week for bonus calculation (default = latest)",
                                        _bonus_week_opts, index=0, key="bonus_week_sel")
    _sel_bonus_week = _bonus_weeks_avail[_bonus_week_opts.index(_sel_bonus_week_str)]

    _bonus_reg = _regional_df[
        (_regional_df['Week'] == _sel_bonus_week) &
        (_regional_df['BUSINESS CITY'].isin(REGIONAL_CITIES))
    ].copy()
    _bonus_comp_reg = _bonus_comp[
        (_bonus_comp['Week'] == _sel_bonus_week) &
        (_bonus_comp['BUSINESS CITY'].isin(REGIONAL_CITIES))
    ].copy()

    if _bonus_reg.empty:
        st.info("No regional data for the selected week.")
    else:
        _drivers_reg = pd.Index(sorted(
            set(_bonus_reg['DRIVER NAME'].dropna()) | set(_bonus_comp_reg['DRIVER NAME'].dropna())))

        _tot_ord = _bonus_reg.groupby('DRIVER NAME')['ID'].count().reindex(_drivers_reg, fill_value=0)
        _avg_dt  = _bonus_comp_reg.groupby('DRIVER NAME')['Average Delivery Time'].mean().reindex(_drivers_reg, fill_value=np.nan)
        _wzone   = (_bonus_reg.groupby('DRIVER NAME')['BUSINESS CITY']
                    .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else "Unknown")
                    .reindex(_drivers_reg, fill_value="Unknown"))

        # City average orders per driver
        _city_ord = _bonus_reg.groupby('BUSINESS CITY')['ID'].count()
        _city_drv = _bonus_reg.groupby('BUSINESS CITY')['DRIVER NAME'].nunique()
        _avg_city = (_city_ord / _city_drv).fillna(0)

        _bonus_df = pd.DataFrame({
            'Rider Name': _drivers_reg,
            'Working Zone': _wzone.values,
            'Total Orders': _tot_ord.values,
            'Avg Delivery Time (min)': _avg_dt.round(1).values
        })
        _bonus_df['City Avg Orders'] = _bonus_df['Working Zone'].map(_avg_city).round(1)
        _bonus_df['Availability Eligible'] = _bonus_df.apply(
            lambda r: '‚úÖ Yes' if r['Total Orders'] > r['City Avg Orders'] else '‚ùå No', axis=1)
        _bonus_df['DT Eligible'] = _bonus_df['Avg Delivery Time (min)'].apply(
            lambda x: '‚úÖ Yes' if pd.notna(x) and x < 50 else '‚ùå No')
        _bonus_df['Availability Bonus'] = _bonus_df['Availability Eligible'].apply(
            lambda x: _BONUS if x == '‚úÖ Yes' else 0)
        _bonus_df['DT Bonus'] = _bonus_df['DT Eligible'].apply(
            lambda x: _BONUS if x == '‚úÖ Yes' else 0)
        _bonus_df['Total Bonus (TZS)'] = _bonus_df['Availability Bonus'] + _bonus_df['DT Bonus']

        # Summary metrics
        _b1, _b2, _b3, _b4 = st.columns(4)
        _b1.metric("üë• Eligible Riders",     f"{len(_bonus_df[_bonus_df['Total Bonus (TZS)']>0])}")
        _b2.metric("üí∞ Total Bonus Payout",  f"{_bonus_df['Total Bonus (TZS)'].sum():,.0f} TZS")
        _b3.metric("‚ö° Avg Orders/Rider",    f"{_bonus_df['Total Orders'].mean():.1f}")
        _b4.metric("‚è± Avg DT (region)",     f"{_avg_dt.mean():.1f} min" if not _avg_dt.isna().all() else "‚Äî")

        st.dataframe(_bonus_df.sort_values('Total Bonus (TZS)', ascending=False),
                     use_container_width=True)

        # Bonus breakdown chart
        _fig_bon, _ax_bon = plt.subplots(figsize=(12,4))
        _top_bon = _bonus_df.sort_values('Total Bonus (TZS)', ascending=False).head(20)
        _bars_b  = _ax_bon.bar(_top_bon['Rider Name'], _top_bon['Total Bonus (TZS)'],
                               color=['#28a745' if v == _BONUS*2 else ('#ffc107' if v == _BONUS else '#dc3545')
                                      for v in _top_bon['Total Bonus (TZS)']])
        _ax_bon.set_ylabel("Bonus (TZS)"); _ax_bon.set_ylim(0, _BONUS * 2.5)
        _ax_bon.set_title(f"Regional Bonus Breakdown ‚Äî Week of {_sel_bonus_week_str}")
        plt.xticks(rotation=45, ha='right', fontsize=8); plt.tight_layout()
        st.pyplot(_fig_bon); plt.close()

        st.download_button("‚¨áÔ∏è Download Bonus Report",
                           data=excel_bytes(_bonus_df, "Bonus"),
                           file_name=f"Regional_Bonus_{_sel_bonus_week_str}.xlsx",
                           mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

        # AI insight for bonus
        _bonus_ctx = (f"REGIONAL BONUS REPORT ‚Äî Week {_sel_bonus_week_str}\n"
                      f"Total riders assessed: {len(_bonus_df)}\n"
                      f"Eligible for bonus: {len(_bonus_df[_bonus_df['Total Bonus (TZS)']>0])}\n"
                      f"Total payout: {_bonus_df['Total Bonus (TZS)'].sum():,.0f} TZS\n"
                      f"Avg delivery time: {_avg_dt.mean():.1f} min\n\n"
                      + _bonus_df.sort_values('Total Bonus (TZS)', ascending=False).head(10).to_string(index=False))
        _bonus_prompt = (
            "Senior BI analyst for a Tanzanian food delivery company.\n\n"
            + _bonus_ctx + "\n\n"
            "Provide:\n"
            "1. **Bonus Summary** ‚Äî What % of riders earned full bonus? Partial? None?\n"
            "2. **Performance Patterns** ‚Äî Which zones are performing best?\n"
            "3. **Underperformers** ‚Äî Who needs coaching and on which metric?\n"
            "4. **Trend Alert** ‚Äî Is regional delivery time improving or declining?\n"
            "5. **Actions** ‚Äî 2 specific ops actions for next week.\nUse real numbers."
        )
        def _run_bonus_insight():
            return claude_insight(_bonus_prompt, max_tokens=700), _bonus_ctx
        ai_insight_button("rider_bonus", "Driver Bonus Analysis", _run_bonus_insight)

        # ‚îÄ‚îÄ‚îÄ Section D: Delivery Time Trends pivot ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        st.markdown("### üìà D. Driver Delivery Time Trends (8 Weeks Pivot)")
        _trend_pivot = (_kpi_all.pivot_table(index='DRIVER NAME', columns='Week',
                                              values='Avg DT (min)', aggfunc='mean')
                        .round(1).reset_index() if _all_kpis else pd.DataFrame())
        if not _trend_pivot.empty:
            _trend_pivot['Working Zone'] = _trend_pivot['DRIVER NAME'].map(_dr_zone)
            _trend_pivot['Avg DT (overall)'] = (_kpi_all.groupby('DRIVER NAME')['Avg DT (min)']
                                                   .mean().round(1).reindex(_trend_pivot['DRIVER NAME']).values)
            st.dataframe(_trend_pivot.sort_values('Avg DT (overall)'), use_container_width=True)
            st.download_button("‚¨áÔ∏è Download DT Trends Pivot",
                               data=excel_bytes(_trend_pivot, "DT Trends"),
                               file_name="Driver_DT_Trends_8W.xlsx",
                               mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TAB 4 ‚Äî PRODUCTS & GEO
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
with tab4:
    st.markdown('<div class="section-header">üì¶ Product Trends & Geographic Analysis</div>', unsafe_allow_html=True)

    # ‚îÄ‚îÄ 8-week default analysis window ‚îÄ‚îÄ
    _p4_all = compute_delivery_stages(df)
    _p4_latest_date = _p4_all['DELIVERY DATE'].dropna().max()
    _p4_8w_start    = _p4_latest_date - pd.Timedelta(weeks=8)
    # Current/latest week bounds for date picker default
    _p4_cw_monday   = _p4_latest_date - pd.Timedelta(days=_p4_latest_date.weekday())
    _p4_cw_sunday   = _p4_cw_monday + pd.Timedelta(days=6)

    st.markdown(
        f"""<div style="background:#e8f4fd;border-left:3px solid #1f77b4;
            padding:10px 14px;border-radius:6px;margin-bottom:12px;font-size:13px;">
        üìÖ <b>Analysis period:</b> Last 8 weeks 
        ({_p4_8w_start.strftime('%d %b')} ‚Äì {_p4_latest_date.strftime('%d %b %Y')}) &nbsp;|&nbsp;
        Latest week: <b>{_p4_cw_monday.strftime('%d %b')} ‚Äì {_p4_cw_sunday.strftime('%d %b %Y')}</b>
        </div>""", unsafe_allow_html=True)

    # Compute date bounds ‚Äî always available
    _p4_min_date   = _p4_all['DELIVERY DATE'].min().date()
    _p4_max_date   = _p4_latest_date.date()
    _p4_8w_clamped = max(_p4_8w_start.date(), _p4_min_date)

    # Always render date pickers (expander keeps them visible/interactive)
    with st.expander("üóìÔ∏è Customize date range (default = last 8 weeks)", expanded=False):
        _p4fc1, _p4fc2 = st.columns(2)
        _p4_from = _p4fc1.date_input("From", value=_p4_8w_clamped,
                                      min_value=_p4_min_date, max_value=_p4_max_date, key="p4_from")
        _p4_to   = _p4fc2.date_input("To",   value=_p4_max_date,
                                      min_value=_p4_min_date, max_value=_p4_max_date, key="p4_to")
    # Retrieve from session state as fallback in case expander hasn't been opened
    _p4_from = st.session_state.get("p4_from", _p4_8w_clamped)
    _p4_to   = st.session_state.get("p4_to",   _p4_max_date)

    # Apply date filter
    _p4_mask = ((_p4_all['DELIVERY DATE'].dt.date >= _p4_from) &
                (_p4_all['DELIVERY DATE'].dt.date <= _p4_to))
    df4 = _p4_all[_p4_mask].copy()

    if df4.empty:
        st.warning("No data in selected date range.")
        st.stop()

    # ‚îÄ‚îÄ Product aggregation ‚îÄ‚îÄ
    product_totals     = defaultdict(int)
    weekly_prod_totals = defaultdict(lambda: defaultdict(int))
    prod_biz_map       = defaultdict(set)

    # Optional product filter within this tab
    prod_filter = st.multiselect("Filter by Product (optional)",
                                  sorted(set(PRODUCT_MAPPING.values())),
                                  key="prod_tab_filter")

    for _, row in df4.iterrows():
        try:
            wk_period = row['DELIVERY DATE'].to_period('W-SUN').start_time
        except Exception:
            continue
        bname = row.get('BUSINESS NAME', '')
        for pname, qty in extract_products(row.get('PRODUCTS', '')):
            pstd = standardize_product(pname)
            if prod_filter and pstd not in prod_filter:
                continue
            product_totals[pstd]                   += qty
            weekly_prod_totals[wk_period][pstd]    += qty
            prod_biz_map[pstd].add(bname)

    if product_totals:
        total_prod_df = pd.DataFrame(product_totals.items(), columns=['Product','Total Quantity'])
        total_prod_df['Businesses Selling']    = total_prod_df['Product'].apply(lambda x: len(prod_biz_map[x]))
        total_prod_df['Associated Businesses'] = total_prod_df['Product'].apply(
            lambda x: ", ".join(sorted(prod_biz_map[x])))
        total_prod_df = total_prod_df.sort_values('Total Quantity', ascending=False)
    else:
        total_prod_df = pd.DataFrame(columns=['Product','Total Quantity','Businesses Selling','Associated Businesses'])
        st.warning("No product data found. Check that the PRODUCTS column has data in format '1 x Item Name'.")

    # ‚îÄ‚îÄ Business performance ‚îÄ‚îÄ
    biz_perf = (df4.groupby('BUSINESS NAME')
                .agg(Total_Orders=('ID','count'), Total_Sales=('SUBTOTAL','sum'),
                     Avg_DT=('Average Delivery Time','mean'))
                .reset_index()
                .sort_values('Total_Orders', ascending=False)
                .head(10)
                .rename(columns={'Avg_DT':'Avg Delivery (min)'}))
    biz_perf['Avg Delivery (min)'] = biz_perf['Avg Delivery (min)'].round(1)

    # ‚îÄ‚îÄ Two column layout ‚îÄ‚îÄ
    pc1, pc2 = st.columns(2)

    with pc1:
        st.subheader("üèÜ Top 10 Businesses")
        st.dataframe(biz_perf, use_container_width=True)
        fig_biz, ax_biz = plt.subplots(figsize=(7, 4))
        ax_biz.barh(biz_perf['BUSINESS NAME'], biz_perf['Total_Orders'], color='#1f77b4')
        ax_biz.set_xlabel("Orders"); ax_biz.invert_yaxis()
        ax_biz.set_title("Top 10 by Orders"); plt.tight_layout()
        st.pyplot(fig_biz); plt.close()

    with pc2:
        st.subheader("üì¶ Top 15 Products")
        st.dataframe(total_prod_df.head(15)[['Product','Total Quantity','Businesses Selling']],
                     use_container_width=True)
        top15 = total_prod_df.head(15)
        fig_prod, ax_prod = plt.subplots(figsize=(7, 4))
        ax_prod.barh(top15['Product'], top15['Total Quantity'], color='#2ca02c')
        ax_prod.set_xlabel("Quantity"); ax_prod.invert_yaxis()
        ax_prod.set_title("Top 15 Products"); plt.tight_layout()
        st.pyplot(fig_prod); plt.close()

    # Downloads
    dc1, dc2 = st.columns(2)
    dc1.download_button("‚¨áÔ∏è Download Business Report",
                        data=excel_bytes(biz_perf, "Top Businesses"),
                        file_name="Top_Businesses.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    dc2.download_button("‚¨áÔ∏è Download Product Trend",
                        data=excel_bytes(total_prod_df, "Products"),
                        file_name="Total_Product_Trend.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

    st.divider()

    # ‚îÄ‚îÄ Weekly Product Movement ‚îÄ‚îÄ
    st.subheader("üìÜ Weekly Product Movement")
    wp_rows = [[w, p, q] for w, prods in weekly_prod_totals.items()
                          for p, q in prods.items()]
    wp_df = pd.DataFrame(wp_rows, columns=['Week','Product','Quantity'])
    if not wp_df.empty:
        # Pivot: products √ó weeks for top 10
        top_prods = total_prod_df.head(10)['Product'].tolist()
        wp_pivot = (wp_df[wp_df['Product'].isin(top_prods)]
                    .pivot_table(index='Product', columns='Week',
                                 values='Quantity', aggfunc='sum', fill_value=0))
        st.dataframe(wp_pivot, use_container_width=True)

        # Line chart ‚Äî top 8
        fig_wp, ax_wp = plt.subplots(figsize=(13, 5))
        for prod in top_prods[:8]:
            prod_data = wp_df[wp_df['Product']==prod].sort_values('Week')
            if prod_data.empty: continue
            ax_wp.plot([str(w.date()) for w in prod_data['Week']],
                       prod_data['Quantity'], marker='o', label=prod)
        ax_wp.set_xlabel("Week"); ax_wp.set_ylabel("Quantity Sold")
        ax_wp.set_title("Weekly Product Trend ‚Äî Top 8 Products")
        ax_wp.legend(fontsize=8, ncol=2); ax_wp.grid(True, alpha=0.3)
        plt.xticks(rotation=45, ha='right'); plt.tight_layout()
        st.pyplot(fig_wp); plt.close()

    # AI
    ai_insight_button("products", "Product Trends", build_product_insight, total_prod_df, biz_perf, wp_df)

    st.divider()

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # GEO INTELLIGENCE ‚Äî Two-panel layout
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    st.divider()
    st.markdown('''<div class="section-header">üó∫Ô∏è Geographic Intelligence ‚Äî Area & Service Analysis</div>''',
                unsafe_allow_html=True)

    _req_geo = ['CUSTOMER LATITUDE','CUSTOMER LONGITUDE','BUSINESS LATITUDE','BUSINESS LONGITUDE']
    if not all(c in df4.columns for c in _req_geo):
        st.info("Geo columns not found in dataset.")
    else:
        _geo4 = df4.dropna(subset=_req_geo).copy()
        if _geo4.empty:
            st.info("No valid geo data for current filter.")
        else:
            # ‚îÄ‚îÄ Compute per-customer delivery metrics ‚îÄ‚îÄ
            _geo4['DT'] = _geo4['Average Delivery Time'].fillna(0)
            _geo4['DistKm'] = _geo4.apply(
                lambda r: haversine(r['BUSINESS LATITUDE'], r['BUSINESS LONGITUDE'],
                                    r['CUSTOMER LATITUDE'], r['CUSTOMER LONGITUDE']), axis=1)

            _center = ([_geo4['CUSTOMER LATITUDE'].mean(), _geo4['CUSTOMER LONGITUDE'].mean()]
                       if city_sel else [-6.8018, 39.2801])

            _rp4 = (_geo4.groupby(['BUSINESS NAME','BUSINESS LATITUDE','BUSINESS LONGITUDE'])
                    .agg(Orders=('ID','count'), Sales=('SUBTOTAL','sum'),
                         AvgDT=('Average Delivery Time','mean'),
                         AvgDist=('DistKm','mean'))
                    .reset_index().sort_values('Orders', ascending=False))

            # ‚îÄ‚îÄ PANEL 1: Density + Polygon Area Analysis ‚îÄ‚îÄ
            st.markdown("### üìç Panel 1 ‚Äî Density Map & Area Analysis")
            st.markdown(
                '''<div style="background:#e8f4fd;border-left:3px solid #1f77b4;padding:8px 14px;
                border-radius:6px;font-size:13px;margin-bottom:10px;">
                üîµ <b>Blue heatmap</b> = Customer density &nbsp;|&nbsp;
                üî¥ <b>Red circles</b> = Restaurants &nbsp;|&nbsp;
                ‚úèÔ∏è <b>Draw a polygon</b> (left toolbar) to analyze any area in detail
                </div>''', unsafe_allow_html=True)

            _p1c1, _p1c2 = st.columns([3,1])
            with _p1c2:
                _map4_type = st.radio("Show layer",
                    ["Both","Customers","Businesses"], key="geo4_type2", label_visibility="collapsed")
                _top_n4    = st.slider("Top restaurants", 5, 50, 20, key="geo4_top2")
                st.caption("üñ±Ô∏è Click any restaurant pin for details")

            with _p1c1:
                _m4 = folium.Map(location=_center, zoom_start=13, tiles="CartoDB positron")

                # Customer heatmap ‚Äî folium default palette (matches Delivery Times tab)
                if _map4_type != "Businesses":
                    _cust_coords = _geo4[['CUSTOMER LATITUDE','CUSTOMER LONGITUDE']].values.tolist()
                    HeatMap(_cust_coords, radius=12, blur=10).add_to(_m4)

                # Restaurant circle markers
                if _map4_type != "Customers":
                    for _, _r in _rp4.head(_top_n4).iterrows():
                        _sz = max(6, min(18, int(_r['Orders'] / max(_rp4['Orders'].max(),1) * 18)))
                        folium.CircleMarker(
                            [_r['BUSINESS LATITUDE'], _r['BUSINESS LONGITUDE']],
                            radius=_sz, color='#e74c3c', fill=True, fill_opacity=0.85,
                            popup=folium.Popup(
                                f"<b>üçΩÔ∏è {_r['BUSINESS NAME']}</b><br>"
                                f"üì¶ <b>{int(_r['Orders']):,}</b> orders<br>"
                                f"üí∞ {int(_r['Sales']):,} TZS<br>"
                                f"‚è±Ô∏è Avg: {_r['AvgDT']:.1f} min &nbsp;|&nbsp; üìè {_r['AvgDist']:.1f} km",
                                max_width=240),
                            tooltip=f"üçΩÔ∏è {_r['BUSINESS NAME']} ({int(_r['Orders']):,} orders)"
                        ).add_to(_m4)

                # Polygon draw tool
                Draw(draw_options={"polyline":False,"polygon":True,"circle":False,
                                   "rectangle":True,"marker":False,"circlemarker":False},
                     edit_options={"edit":True,"remove":True}).add_to(_m4)
                folium.LayerControl().add_to(_m4)
                _map4_data = st_folium(_m4, height=500, key="geo4_map_v2", use_container_width=True)

            # ‚îÄ‚îÄ Polygon analysis ‚îÄ‚îÄ
            if _map4_data and _map4_data.get("all_drawings"):
                _coords = _map4_data["all_drawings"][-1]["geometry"]["coordinates"][0]
                _poly   = Polygon([(c[1], c[0]) for c in _coords])
                _geo4["_in_poly"] = _geo4.apply(
                    lambda r: _poly.contains(Point(r["CUSTOMER LATITUDE"], r["CUSTOMER LONGITUDE"])), axis=1)
                _area_df = _geo4[_geo4["_in_poly"]].copy()

                if not _area_df.empty:
                    st.markdown("---")
                    st.markdown(f"### üìä Selected Area Analysis ‚Äî **{len(_area_df):,} orders**")

                    _ac1, _ac2, _ac3, _ac4, _ac5 = st.columns(5)
                    _ac1.metric("üì¶ Orders", f"{len(_area_df):,}")
                    _ac2.metric("üí∞ Sales", f"{_area_df['SUBTOTAL'].sum()/1e6:.2f}M TZS")
                    _ac3.metric("‚è±Ô∏è Avg Delivery", f"{_area_df['DT'].mean():.1f} min")
                    _ac4.metric("üìè Avg Distance", f"{_area_df['DistKm'].mean():.1f} km")
                    _ac5.metric("üë§ Unique Customers", f"{_area_df['CUSTOMER NAME'].nunique():,}")

                    _ab_c1, _ab_c2 = st.columns(2)
                    with _ab_c1:
                        st.markdown("##### üçΩÔ∏è Top Businesses in Area")
                        _area_biz = (_area_df.groupby("BUSINESS NAME")
                                     .agg(Orders=("ID","count"), Sales=("SUBTOTAL","sum"),
                                          AvgDT=("DT","mean"), AvgDist=("DistKm","mean"))
                                     .reset_index().sort_values("Orders", ascending=False))
                        _area_biz["Sales"] = _area_biz["Sales"].apply(lambda x: f"{int(x):,}")
                        _area_biz["AvgDT"] = _area_biz["AvgDT"].round(1)
                        _area_biz["AvgDist"] = _area_biz["AvgDist"].round(2)
                        st.dataframe(_area_biz.head(10), use_container_width=True)

                    with _ab_c2:
                        st.markdown("##### üë• Top Customers in Area")
                        _area_cust = (_area_df.groupby("CUSTOMER NAME")
                                      .agg(Orders=("ID","count"), Spend=("SUBTOTAL","sum"),
                                           AvgDT=("DT","mean"))
                                      .reset_index().sort_values("Spend", ascending=False))
                        _area_cust["Spend"] = _area_cust["Spend"].apply(lambda x: f"{int(x):,} TZS")
                        st.dataframe(_area_cust.head(10), use_container_width=True)

                    st.download_button("‚¨áÔ∏è Download Area Orders (CSV)",
                                       data=_area_df.drop(columns=["_in_poly","_in_cluster"], errors="ignore").to_csv(index=False).encode(),
                                       file_name="selected_area_orders.csv", mime="text/csv",
                                       key="dl_area_orders")

                    # Auto AI insight for polygon selection
                    _area_ctx = (
                        f"AREA SELECTED: {len(_area_df):,} orders | "
                        f"{_area_df['SUBTOTAL'].sum()/1e6:.2f}M TZS sales | "
                        f"Avg delivery {_area_df['DT'].mean():.1f} min | "
                        f"Avg distance {_area_df['DistKm'].mean():.1f} km | "
                        f"{_area_df['CUSTOMER NAME'].nunique()} unique customers\n\n"
                        f"Top businesses:\n{_area_biz.head(8).to_string(index=False)}"
                    )
                    _area_prompt = (
                        "You are a senior operations analyst for a Tanzanian food delivery company.\n"
                        + _area_ctx + "\n\n"
                        "Analyze this specific geographic area:\n"
                        "1. **Zone Health** ‚Äî Is this area well-served or underserved given the delivery times?\n"
                        "2. **Service Quality** ‚Äî Is avg delivery time and distance acceptable? Any bottlenecks?\n"
                        "3. **Business Mix** ‚Äî Which businesses drive the area? Any gaps or opportunities?\n"
                        "4. **Customer Value** ‚Äî What is the revenue concentration in this zone?\n"
                        "5. **Action** ‚Äî One specific operational recommendation for this zone.\n"
                        "Use real numbers. Be direct and specific."
                    )
                    with st.spinner("ü§ñ Analyzing selected area‚Ä¶"):
                        _area_ins = claude_insight(_area_prompt, 600)
                    ai_block("geo_area_v2", _area_ctx, _area_ins)
                else:
                    st.warning("‚ö†Ô∏è No orders found inside the drawn area. Try a larger polygon.")

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # PANEL 2 ‚Äî Service Quality Cluster Map
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            st.divider()
            st.markdown("### üî¥ Panel 2 ‚Äî Service Quality Intelligence: Hard-to-Serve Areas")
            st.markdown('''
            <div style="background:#fff3cd;border-left:3px solid #f39c12;padding:10px 16px;
                        border-radius:6px;font-size:13px;margin-bottom:12px;">
            <b>How to read this map:</b> Circles = customer zones clustered by proximity (1 km radius).
            Color shows <b>average delivery time</b> ‚Äî üî¥ Red = struggling zones (slow delivery),
            üü¢ Green = well-served. Circle size = order volume.
            <b>Click any circle</b> for detailed zone analysis.
            </div>''', unsafe_allow_html=True)

            # Control row
            _sq_c1, _sq_c2, _sq_c3 = st.columns([2,2,2])
            with _sq_c1:
                _dt_thresh = st.slider("üî¥ Flag zones slower than (min)", 20, 90, 45, key="geo_dt_thresh",
                                       help="Delivery time threshold ‚Äî zones above this are flagged red")
            with _sq_c2:
                _min_orders = st.slider("Min orders to show zone", 1, 20, 3, key="geo_min_orders",
                                        help="Filter out low-activity zones")
            with _sq_c3:
                _cluster_km = st.select_slider("Cluster radius", options=[0.5,1.0,1.5,2.0,3.0],
                                               value=1.0, key="geo_cluster_km",
                                               help="Group customers within this radius into one zone")

            # ‚îÄ‚îÄ Cluster customers by grid approximation (fast, no sklearn needed) ‚îÄ‚îÄ
            # Round lat/lon to cluster_km degree equivalent
            _deg_per_km = 1.0 / 111.0
            _grid_size  = _cluster_km * _deg_per_km
            _geo4["_lat_g"] = (_geo4["CUSTOMER LATITUDE"]  / _grid_size).round(0) * _grid_size
            _geo4["_lon_g"] = (_geo4["CUSTOMER LONGITUDE"] / _grid_size).round(0) * _grid_size

            _clusters = (_geo4.groupby(["_lat_g","_lon_g"])
                         .agg(Orders=('ID','count'),
                              Sales=('SUBTOTAL','sum'),
                              AvgDT=('DT','mean'),
                              AvgDist=('DistKm','mean'),
                              Unique_Cust=('CUSTOMER NAME','nunique'),
                              AvgOrder=('SUBTOTAL','mean'),
                              Lat=('CUSTOMER LATITUDE','mean'),
                              Lon=('CUSTOMER LONGITUDE','mean'))
                         .reset_index()
                         .rename(columns={"_lat_g":"GridLat","_lon_g":"GridLon"}))

            _clusters = _clusters[_clusters["Orders"] >= _min_orders].copy()
            _clusters["ServiceScore"] = _clusters["AvgDT"]  # higher = worse

            # Color by delivery time vs threshold
            def _zone_color(avg_dt):
                if avg_dt >= _dt_thresh:           return "#e74c3c"   # üî¥ struggling
                elif avg_dt >= _dt_thresh * 0.75:  return "#f39c12"   # üü† moderate
                elif avg_dt >= _dt_thresh * 0.55:  return "#f1c40f"   # üü° ok
                else:                               return "#27ae60"   # üü¢ good

            # ‚îÄ‚îÄ Build service quality map ‚îÄ‚îÄ
            _m5 = folium.Map(location=_center, zoom_start=13, tiles="CartoDB positron")

            # Add restaurant markers (smaller, grey)
            for _, _r in _rp4.head(30).iterrows():
                folium.CircleMarker(
                    [_r['BUSINESS LATITUDE'], _r['BUSINESS LONGITUDE']],
                    radius=6, color='#636e72', fill=True, fill_opacity=0.7,
                    tooltip=f"üçΩÔ∏è {_r['BUSINESS NAME']}",
                    popup=folium.Popup(
                        f"<b>{_r['BUSINESS NAME']}</b><br>"
                        f"Avg delivery: {_r['AvgDT']:.1f} min | {_r['AvgDist']:.1f} km avg",
                        max_width=200)
                ).add_to(_m5)

            # Add customer zone circles
            _max_orders = max(_clusters["Orders"].max(), 1)
            for _, _cl in _clusters.iterrows():
                _col   = _zone_color(_cl["AvgDT"])
                _rad   = max(8, min(30, int(_cl["Orders"] / _max_orders * 30)))
                _border = "#c0392b" if _cl["AvgDT"] >= _dt_thresh else "#2c3e50"

                # Build rich popup HTML
                _dt_flag = "üî¥ SLOW" if _cl["AvgDT"] >= _dt_thresh else ("üü†" if _cl["AvgDT"] >= _dt_thresh*0.75 else "üü¢ Good")
                _popup_html = (
                    f"<div style='min-width:220px;font-size:13px;'>"
                    f"<b style='font-size:14px;'>üìç Customer Zone</b><br>"
                    f"<hr style='margin:4px 0;'>"
                    f"üì¶ <b>{int(_cl['Orders']):,}</b> orders &nbsp;|&nbsp; "
                    f"üë§ {int(_cl['Unique_Cust']):,} customers<br>"
                    f"üí∞ Avg order: <b>{int(_cl['AvgOrder']):,} TZS</b><br>"
                    f"‚è±Ô∏è Avg delivery: <b>{_cl['AvgDT']:.1f} min</b> {_dt_flag}<br>"
                    f"üìè Avg distance: <b>{_cl['AvgDist']:.1f} km</b><br>"
                    f"üíµ Zone revenue: <b>{int(_cl['Sales']):,} TZS</b>"
                    f"</div>"
                )

                folium.CircleMarker(
                    [_cl["Lat"], _cl["Lon"]],
                    radius=_rad,
                    color=_border, fill=True,
                    fill_color=_col, fill_opacity=0.65,
                    popup=folium.Popup(_popup_html, max_width=280),
                    tooltip=(f"‚è±Ô∏è {_cl['AvgDT']:.0f} min | üì¶ {int(_cl['Orders']):,} orders")
                ).add_to(_m5)

            # Legend
            folium.Marker(
                location=[_center[0] - 0.02, _center[1] + 0.04],
                icon=folium.DivIcon(html=f"""
                <div style='background:white;border:1px solid #ccc;border-radius:6px;
                             padding:8px 12px;font-size:12px;box-shadow:2px 2px 6px rgba(0,0,0,0.15);
                             white-space:nowrap;'>
                  <b>Service Level</b><br>
                  <span style='color:#27ae60;'>‚óè</span> Good (&lt;{int(_dt_thresh*0.55)}min)<br>
                  <span style='color:#f1c40f;'>‚óè</span> OK ({int(_dt_thresh*0.55)}‚Äì{int(_dt_thresh*0.75)}min)<br>
                  <span style='color:#f39c12;'>‚óè</span> Moderate ({int(_dt_thresh*0.75)}‚Äì{_dt_thresh}min)<br>
                  <span style='color:#e74c3c;'>‚óè</span> Slow (&gt;{_dt_thresh}min)<br>
                  <span style='color:#636e72;'>‚óè</span> Restaurant
                </div>""", icon_size=(0,0), icon_anchor=(0,0))
            ).add_to(_m5)

            st.components.v1.html(_m5._repr_html_(), height=520)

            # ‚îÄ‚îÄ Struggling zones table + comparison ‚îÄ‚îÄ
            _struggling = _clusters[_clusters["AvgDT"] >= _dt_thresh].sort_values("AvgDT", ascending=False)
            _good_zones = _clusters[_clusters["AvgDT"] < _dt_thresh * 0.55].sort_values("Orders", ascending=False)

            _sq_t1, _sq_t2 = st.columns(2)
            with _sq_t1:
                st.markdown(f"#### üî¥ Struggling Zones (>{_dt_thresh} min avg delivery)")
                if not _struggling.empty:
                    _str_disp = _struggling[['Lat','Lon','Orders','AvgDT','AvgDist','AvgOrder','Sales']].copy()
                    _str_disp['Lat'] = _str_disp['Lat'].round(4)
                    _str_disp['Lon'] = _str_disp['Lon'].round(4)
                    _str_disp['AvgDT'] = _str_disp['AvgDT'].round(1)
                    _str_disp['AvgDist'] = _str_disp['AvgDist'].round(2)
                    _str_disp['AvgOrder'] = _str_disp['AvgOrder'].apply(lambda x: f"{int(x):,}")
                    _str_disp['Sales'] = _str_disp['Sales'].apply(lambda x: f"{int(x):,}")
                    _str_disp.index = range(1, len(_str_disp)+1)
                    st.dataframe(_str_disp, use_container_width=True)
                else:
                    st.success(f"‚úÖ No zones with avg delivery > {_dt_thresh} min!")

            with _sq_t2:
                st.markdown("#### üü¢ Best-Served Zones (fastest delivery)")
                if not _good_zones.empty:
                    _good_disp = _good_zones[['Lat','Lon','Orders','AvgDT','AvgDist','AvgOrder','Sales']].copy()
                    _good_disp['Lat'] = _good_disp['Lat'].round(4)
                    _good_disp['Lon'] = _good_disp['Lon'].round(4)
                    _good_disp['AvgDT'] = _good_disp['AvgDT'].round(1)
                    _good_disp['AvgDist'] = _good_disp['AvgDist'].round(2)
                    _good_disp['AvgOrder'] = _good_disp['AvgOrder'].apply(lambda x: f"{int(x):,}")
                    _good_disp['Sales'] = _good_disp['Sales'].apply(lambda x: f"{int(x):,}")
                    _good_disp.index = range(1, len(_good_disp)+1)
                    st.dataframe(_good_disp, use_container_width=True)
                else:
                    st.info("Adjust threshold to see well-served zones.")

            # ‚îÄ‚îÄ Download cluster data ‚îÄ‚îÄ
            _sq_d1, _sq_d2 = st.columns(2)
            _sq_d1.download_button("‚¨áÔ∏è All Zones (Excel)",
                data=excel_bytes(_clusters.drop(columns=["GridLat","GridLon","_lat_g","_lon_g"], errors="ignore")
                                 .rename(columns={"Lat":"Center Lat","Lon":"Center Lon"})
                                 .sort_values("AvgDT", ascending=False), "All Zones"),
                file_name="Service_Quality_Zones.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                key="dl_zones")
            _sq_d2.download_button("‚¨áÔ∏è Struggling Zones (Excel)",
                data=excel_bytes(_struggling.rename(columns={"Lat":"Center Lat","Lon":"Center Lon"}), "Struggling"),
                file_name="Struggling_Zones.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                key="dl_struggling")

            # ‚îÄ‚îÄ AI Insight for service quality ‚îÄ‚îÄ
            if not _struggling.empty:
                _sq_ctx = (
                    f"GEOGRAPHIC SERVICE QUALITY ANALYSIS\n"
                    f"Total zones: {len(_clusters)} | Struggling zones (>{_dt_thresh}min): {len(_struggling)}\n"
                    f"Overall avg delivery: {_clusters['AvgDT'].mean():.1f} min | "
                    f"Worst zone: {_struggling['AvgDT'].max():.1f} min avg\n"
                    f"Avg distance struggling zones: {_struggling['AvgDist'].mean():.1f} km\n\n"
                    f"TOP STRUGGLING ZONES:\n{_struggling.head(8)[['Lat','Lon','Orders','AvgDT','AvgDist','Sales']].round(2).to_string(index=False)}\n\n"
                    f"BEST ZONES:\n{_good_zones.head(5)[['Lat','Lon','Orders','AvgDT','AvgDist']].round(2).to_string(index=False)}"
                )
                _sq_prompt = (
                    "You are a senior logistics analyst for Piki, a Tanzanian food delivery company.\n\n"
                    + _sq_ctx + "\n\n"
                    "Provide a geographic service quality analysis:\n"
                    "1. **Coverage Gaps** ‚Äî Which areas are consistently underserved? What patterns do you see?\n"
                    "2. **Distance vs Time** ‚Äî Is poor service caused by distance or operational issues?\n"
                    "3. **Revenue at Risk** ‚Äî How much revenue is at risk in struggling zones due to poor service?\n"
                    "4. **Quick Wins** ‚Äî Which 2-3 struggling zones should be prioritized first and why?\n"
                    "5. **Recommendations** ‚Äî Specific actions: add restaurant, deploy riders, set delivery boundaries?\n"
                    "Use real numbers. Be operational and specific."
                )
                ai_insight_button("geo_service_quality", "Service Quality Analysis", lambda: (claude_insight(_sq_prompt, 700), _sq_ctx))

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TAB 5 ‚Äî PIKI PARTY STORE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
with tab5:
    st.markdown("""
    <div style="background:linear-gradient(135deg,#ff6b6b,#ffd93d,#6bcb77,#4d96ff);
                padding:20px 24px; border-radius:14px; margin-bottom:20px;">
        <h2 style="color:white;margin:0;text-shadow:1px 1px 3px rgba(0,0,0,0.4);">
            üéâ Piki Party Store ‚Äî Intelligence Dashboard
        </h2>
        <p style="color:rgba(255,255,255,0.92);margin:6px 0 0 0;font-size:15px;">
            Product trends ¬∑ Category analysis ¬∑ Customer insights
        </p>
    </div>
    """, unsafe_allow_html=True)

    # ‚îÄ‚îÄ Filter to Piki Party only ‚îÄ‚îÄ
    _pp_df = raw.copy()
    _pp_df['DELIVERY DATE'] = pd.to_datetime(_pp_df['DELIVERY DATE'], errors='coerce')
    _pp_df['DELIVERY TIME'] = pd.to_datetime(_pp_df['DELIVERY TIME'], errors='coerce')
    _pp_df['HOUR'] = _pp_df['DELIVERY TIME'].dt.hour
    _pp_df = _pp_df[_pp_df['HOUR'].isin(OPERATING_HOURS)]

    _pp_df = _pp_df[_pp_df['BUSINESS NAME'].str.strip().str.lower() == 'piki party'].copy()

    if _pp_df.empty:
        st.warning("No 'Piki Party' orders found in the uploaded data. Check that BUSINESS NAME contains 'Piki Party'.")
        st.stop()

    _iso = _pp_df['DELIVERY DATE'].dt.isocalendar()
    _pp_df['ISO_Year'] = _iso.year
    _pp_df['ISO_Week'] = _iso.week

    # ‚îÄ‚îÄ Load category master ‚îÄ‚îÄ
    _cat_loaded = False
    _product_category_map = {}
    try:
        _cdf = pd.read_csv("Products Category.csv", encoding='utf-8')
    except Exception:
        try:
            _cdf = pd.read_csv("Products Category.csv", encoding='latin1')
        except Exception:
            _cdf = pd.DataFrame(columns=['Product','Category'])
            st.info("Products Category.csv not found ‚Äî categories will show as UNCATEGORIZED.")

    if not _cdf.empty:
        _cdf['Product']  = _cdf['Product'].str.strip().str.lower()
        _cdf['Category'] = _cdf['Category'].str.strip()
        _product_category_map = dict(zip(_cdf['Product'], _cdf['Category']))
        _cat_loaded = True

    # ‚îÄ‚îÄ KPI Summary ‚îÄ‚îÄ
    _pp_comp = _pp_df[_pp_df['STATE'].isin(['Completed','Delivery Completed By Driver'])]
    _pp_fail = _pp_df[_pp_df['STATE'] == 'Delivery Failed By Driver']
    _pp_rej  = _pp_df[_pp_df['STATE'].str.contains('Reject', na=False)]

    _pk1,_pk2,_pk3,_pk4,_pk5 = st.columns(5)
    _pk1.metric("üì¶ Total Orders",    f"{len(_pp_df):,}")
    _pk2.metric("‚úÖ Completed",        f"{len(_pp_comp):,}")
    _pk3.metric("‚ùå Failed",           f"{len(_pp_fail)}")
    _pk4.metric("üö´ Rejected",         f"{len(_pp_rej)}")
    _pk5.metric("üí∞ Total Sales",      f"{_pp_comp['SUBTOTAL'].sum()/1e6:.2f}M TZS")

    # ‚îÄ‚îÄ Filters row ‚îÄ‚îÄ
    st.markdown("---")
    st.markdown("#### üîé Filters")
    _pf1,_pf2,_pf3,_pf4 = st.columns(4)

    with _pf1:
        _pp_states = sorted(_pp_df['STATE'].dropna().unique())
        _state_sel = st.multiselect("Order Status", _pp_states, default=_pp_states, key="pp_state")

    with _pf2:
        _all_cats = sorted(set(_product_category_map.values())) if _product_category_map else []
        _cat_sel  = st.multiselect("Category", _all_cats, key="pp_cat")

    with _pf3:
        _pp_min_d = _pp_df['DELIVERY DATE'].min().date()
        _pp_max_d = _pp_df['DELIVERY DATE'].max().date()
        _pp_date_range = st.date_input("Date Range",
            value=[_pp_min_d, _pp_max_d],
            min_value=_pp_min_d, max_value=_pp_max_d,
            key="pp_dates")

    with _pf4:
        _pp_hour_opt = st.selectbox("Time Period",
            ["All Day","Morning (7-11)","Afternoon (12-16)","Evening (17-22)","Late Night (23-2)"],
            key="pp_hour")

    # Apply filters
    if _state_sel:
        _pp_df = _pp_df[_pp_df['STATE'].isin(_state_sel)]
    if len(_pp_date_range) == 2:
        _pp_df = _pp_df[
            (_pp_df['DELIVERY DATE'] >= pd.to_datetime(_pp_date_range[0])) &
            (_pp_df['DELIVERY DATE'] <= pd.to_datetime(_pp_date_range[1]))]
    if _pp_hour_opt == "Morning (7-11)":
        _pp_df = _pp_df[_pp_df['HOUR'].between(7,11)]
    elif _pp_hour_opt == "Afternoon (12-16)":
        _pp_df = _pp_df[_pp_df['HOUR'].between(12,16)]
    elif _pp_hour_opt == "Evening (17-22)":
        _pp_df = _pp_df[_pp_df['HOUR'].between(17,22)]
    elif _pp_hour_opt == "Late Night (23-2)":
        _pp_df = _pp_df[(_pp_df['HOUR']>=23)|(_pp_df['HOUR']<=2)]

    _pp_comp = _pp_df[_pp_df['STATE'].isin(['Completed','Delivery Completed By Driver'])]

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # WEEKLY ORDERS & SALES TREND
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    st.markdown("---")
    st.markdown('<div class="section-header">üìà Weekly Orders & Sales Trend</div>', unsafe_allow_html=True)

    _pp_weekly = (_pp_comp.groupby(['ISO_Year','ISO_Week'])
                  .agg(Total_Orders=('ID','count'), Total_Sales=('SUBTOTAL','sum'))
                  .reset_index()
                  .sort_values(['ISO_Year','ISO_Week']))
    _pp_weekly['Week_Label'] = (_pp_weekly['ISO_Year'].astype(str) + "-W"
                                + _pp_weekly['ISO_Week'].astype(str).str.zfill(2))

    if not _pp_weekly.empty:
        _fw, _ax1p = plt.subplots(figsize=(12,5))
        _ax1p.plot(_pp_weekly['Week_Label'], _pp_weekly['Total_Orders'],
                   marker='o', color='#4d96ff', lw=2, label='Orders')
        _ax1p.set_ylabel("Orders", color='#4d96ff'); _ax1p.grid(True, alpha=0.3)
        _ax2p = _ax1p.twinx()
        _ax2p.bar(_pp_weekly['Week_Label'], _pp_weekly['Total_Sales'],
                  alpha=0.3, color='#6bcb77', label='Sales')
        _ax2p.yaxis.set_major_formatter(fmt_millions); _ax2p.set_ylabel("Sales (TZS)")
        _l1,_lb1 = _ax1p.get_legend_handles_labels()
        _l2,_lb2 = _ax2p.get_legend_handles_labels()
        _ax1p.legend(_l1+_l2, _lb1+_lb2, loc='upper left')
        plt.title("Piki Party ‚Äî Weekly Orders & Sales"); plt.xticks(rotation=35, ha='right')
        plt.tight_layout(); st.pyplot(_fw); plt.close()
        st.dataframe(_pp_weekly[['Week_Label','Total_Orders','Total_Sales']].rename(
            columns={'Week_Label':'Week','Total_Orders':'Orders','Total_Sales':'Sales (TZS)'}),
            use_container_width=True)
    else:
        st.info("No completed orders in selected period.")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # PRODUCT ANALYSIS
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    st.markdown("---")
    st.markdown('<div class="section-header">üì¶ Product & Category Analysis</div>', unsafe_allow_html=True)

    # Build product-week matrix
    _pp_prod_totals = defaultdict(int)
    _pp_wk_prod     = defaultdict(lambda: defaultdict(int))

    for _, _row in _pp_comp.iterrows():
        _wk = int(_row['ISO_Week'])
        for _pn, _qty in extract_products(_row.get('PRODUCTS','')):
            _ps = standardize_product(_pn)
            _pp_prod_totals[_ps]      += _qty
            _pp_wk_prod[_ps][_wk]     += _qty

    if _pp_prod_totals:
        _week_cols_pp = sorted(_pp_weekly['ISO_Week'].unique().astype(int))[-8:]

        _pp_matrix_rows = []
        for _prod, _total in _pp_prod_totals.items():
            _r = {'Product': _prod,
                  'Category': _product_category_map.get(_prod.lower(), 'UNCATEGORIZED')}
            for _w in _week_cols_pp:
                _r[f'W{_w}'] = _pp_wk_prod[_prod].get(_w, 0)
            _r['Total Qty'] = _total
            _pp_matrix_rows.append(_r)

        _pp_matrix = pd.DataFrame(_pp_matrix_rows).sort_values('Total Qty', ascending=False)

        if _cat_sel:
            _pp_matrix = _pp_matrix[_pp_matrix['Category'].isin(_cat_sel)]

        _wcols_disp = [f'W{w}' for w in _week_cols_pp]

        # Display with ‚ùå for zeros
        _pp_display = _pp_matrix.copy()
        for _c in _wcols_disp:
            _pp_display[_c] = _pp_display[_c].apply(lambda x: "‚ùå" if x==0 else int(x))

        _pt1, _pt2 = st.tabs(["üî• Top Selling Items", "üìä Category Rankings"])

        with _pt1:
            st.dataframe(_pp_display[['Product','Category']+_wcols_disp+['Total Qty']],
                         use_container_width=True)

        with _pt2:
            _cat_rank = (_pp_matrix.groupby('Category')[_wcols_disp+['Total Qty']]
                         .sum().reset_index().sort_values('Total Qty', ascending=False))
            _cat_rank = _cat_rank[_cat_rank['Category'] != 'UNCATEGORIZED']
            _cat_disp = _cat_rank.copy()
            for _c in _wcols_disp:
                _cat_disp[_c] = _cat_disp[_c].apply(lambda x: "‚ùå" if x==0 else int(x))
            st.dataframe(_cat_disp, use_container_width=True)

        # ‚îÄ‚îÄ Charts ‚îÄ‚îÄ
        _vc1, _vc2 = st.columns(2)

        with _vc1:
            st.markdown("##### üèÜ Top 10 Products")
            _top10p = _pp_matrix.head(10)
            _fpt, _apt = plt.subplots(figsize=(6,4))
            _bars = _apt.barh(_top10p['Product'], _top10p['Total Qty'],
                              color=plt.cm.Set3(np.linspace(0,1,len(_top10p))))
            _apt.invert_yaxis(); _apt.set_xlabel("Qty")
            _apt.bar_label(_bars, padding=3, fontsize=8)
            plt.tight_layout(); st.pyplot(_fpt); plt.close()

        with _vc2:
            st.markdown("##### ü•ß Category Share")
            _cat_pie = _pp_matrix.groupby('Category')['Total Qty'].sum().reset_index()
            _cat_pie = _cat_pie[_cat_pie['Category'] != 'UNCATEGORIZED']
            _total_qty = _cat_pie['Total Qty'].sum()
            _major = _cat_pie[_cat_pie['Total Qty']/_total_qty >= 0.015]
            _others_v = _cat_pie[_cat_pie['Total Qty']/_total_qty < 0.015]['Total Qty'].sum()
            if _others_v > 0:
                _major = pd.concat([_major, pd.DataFrame({'Category':['Others'],'Total Qty':[_others_v]})])
            _fpc, _apc = plt.subplots(figsize=(6,4))
            _apc.pie(_major['Total Qty'], labels=_major['Category'],
                     autopct='%1.1f%%', startangle=90,
                     colors=plt.cm.Set3(np.linspace(0,1,len(_major))))
            _apc.axis('equal'); plt.tight_layout(); st.pyplot(_fpc); plt.close()

        # ‚îÄ‚îÄ Category Trend ‚îÄ‚îÄ
        st.markdown("##### üìà Category Weekly Trend")
        if len(_wcols_disp) >= 2 and not _cat_rank.empty:
            _fct, _act = plt.subplots(figsize=(12,4))
            for _, _crow in _cat_rank.iterrows():
                _vals = [_pp_matrix[_pp_matrix['Category']==_crow['Category']][_c].sum()
                         for _c in _wcols_disp]
                _act.plot([c.replace('W','W') for c in _wcols_disp], _vals,
                          marker='o', lw=2, label=_crow['Category'])
            _act.set_xlabel("Week"); _act.set_ylabel("Qty"); _act.grid(True, alpha=0.3)
            _act.legend(fontsize=8, ncol=3); plt.xticks(rotation=30)
            plt.title("Category Volume by Week"); plt.tight_layout()
            st.pyplot(_fct); plt.close()

        # ‚îÄ‚îÄ WoW Growth ‚îÄ‚îÄ
        if len(_wcols_disp) >= 2:
            st.markdown("##### üìä Week-over-Week Category Growth %")
            _last_w, _prev_w = _wcols_disp[-1], _wcols_disp[-2]
            _cat_rank = _cat_rank.copy()
            _cat_rank['WoW %'] = ((_cat_rank[_last_w] - _cat_rank[_prev_w])
                                   / _cat_rank[_prev_w].replace(0, np.nan) * 100).fillna(0)
            _gwow = _cat_rank.sort_values('WoW %', ascending=False)
            _fwow, _awow = plt.subplots(figsize=(10,4))
            _colors_wow = ['#28a745' if v >= 0 else '#dc3545' for v in _gwow['WoW %']]
            _awow.bar(_gwow['Category'], _gwow['WoW %'], color=_colors_wow)
            _awow.axhline(0, color='black', lw=0.8)
            _awow.set_ylabel("Growth %"); _awow.set_title(f"WoW Growth: {_prev_w} ‚Üí {_last_w}")
            plt.xticks(rotation=35, ha='right'); plt.tight_layout()
            st.pyplot(_fwow); plt.close()

        # ‚îÄ‚îÄ Growth vs Volume bubble ‚îÄ‚îÄ
        st.markdown("##### ü´ß Category: Growth Trajectory vs Volume")
        if len(_wcols_disp) >= 3 and not _cat_rank.empty:
            _slopes = []
            for _, _cr in _cat_rank.iterrows():
                _v = [_pp_matrix[_pp_matrix['Category']==_cr['Category']][_c].sum()
                      for _c in _wcols_disp]
                _slopes.append(np.polyfit(range(len(_v)), _v, 1)[0] if sum(_v) > 0 else 0)
            _cat_rank['Slope'] = _slopes
            _fbub, _abub = plt.subplots(figsize=(10,5))
            _abub.scatter(_cat_rank['Total Qty'], _cat_rank['Slope'],
                          s=(_cat_rank['Total Qty']/max(_cat_rank['Total Qty'].max(),1)*800+50),
                          c=plt.cm.Set2(np.linspace(0,1,len(_cat_rank))), alpha=0.8, edgecolors='white', lw=1.5)
            for _, _cr in _cat_rank.iterrows():
                _abub.annotate(_cr['Category'], (_cr['Total Qty'], _cr['Slope']),
                               fontsize=8, ha='center', va='bottom')
            _abub.axhline(0, color='gray', lw=1, linestyle='--')
            _abub.set_xlabel("Total Volume"); _abub.set_ylabel("Trend (slope)")
            _abub.set_title("Growth Trajectory vs Volume ‚Äî bigger bubble = more volume")
            plt.tight_layout(); st.pyplot(_fbub); plt.close()

    else:
        st.info("No product data could be extracted from PRODUCTS column.")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # TOP ORDERS BY VALUE
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    st.markdown("---")
    st.markdown('<div class="section-header">üí∞ Top Orders by Value</div>', unsafe_allow_html=True)

    _top_ord = _pp_comp.sort_values('SUBTOTAL', ascending=False).copy()
    _top_ord['Order Date']       = _top_ord['DELIVERY DATE'].dt.date
    _top_ord['Products Ordered'] = _top_ord['PRODUCTS'].apply(format_products_clean)
    _top_ord_view = _top_ord[['ID','Order Date','CUSTOMER NAME','Products Ordered','SUBTOTAL']].head(20)
    _top_ord_view = _top_ord_view.rename(columns={'ID':'Order ID','CUSTOMER NAME':'Customer',
                                                   'SUBTOTAL':'Value (TZS)'})
    st.dataframe(_top_ord_view, use_container_width=True)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # DEEP ANALYTICS SECTIONS
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    st.markdown("---")
    st.markdown('<div class="section-header">üî¨ Deep Analytics</div>', unsafe_allow_html=True)

    _da_tab1, _da_tab2, _da_tab3, _da_tab4, _da_tab5 = st.tabs([
        "üç∂ Soju Analysis", "üì¶ Wholesale", "‚ùå Cancelled Orders", "üöó Pickup Orders", "üåô Late Night"
    ])

    # ‚îÄ‚îÄ Build useful derived data ‚îÄ‚îÄ
    _all_pp = raw[raw['BUSINESS NAME'].str.strip().str.lower() == 'piki party'].copy()
    _all_pp['DELIVERY DATE'] = pd.to_datetime(_all_pp['DELIVERY DATE'], errors='coerce')
    _all_pp['DELIVERY TIME'] = pd.to_datetime(_all_pp['DELIVERY TIME'], errors='coerce')
    _all_pp['HOUR'] = _all_pp['DELIVERY TIME'].dt.hour
    _all_pp_iso = _all_pp['DELIVERY DATE'].dt.isocalendar()
    _all_pp['ISO_Week'] = _all_pp_iso.week
    _all_pp['ISO_Year'] = _all_pp_iso.year

    # Identify latest & previous weeks ‚Äî use (Year, Week) pair to avoid year boundary bugs
    _pp_latest_row = (_all_pp.dropna(subset=['DELIVERY DATE'])
                      .sort_values('DELIVERY DATE').iloc[-1])
    _pp_max_yr  = int(_pp_latest_row['ISO_Year'])
    _pp_max_wk  = int(_pp_latest_row['ISO_Week'])
    # Previous week ‚Äî handle year boundary (week 1 of new year follows week 52/53)
    if _pp_max_wk > 1:
        _pp_prev_wk = _pp_max_wk - 1
        _pp_prev_yr = _pp_max_yr
    else:
        _pp_prev_yr = _pp_max_yr - 1
        # Check if prev year had 53 ISO weeks (e.g. 2020, 2015 had 53)
        _dec28_prev = pd.Timestamp(f"{_pp_prev_yr}-12-28")
        _pp_prev_wk = int(_dec28_prev.isocalendar()[1])  # Dec 28 always in last ISO week
    # Filter helpers
    def _pp_is_cur(r):   return int(r['ISO_Year'])==_pp_max_yr and int(r['ISO_Week'])==_pp_max_wk
    def _pp_is_prev(r):  return int(r['ISO_Year'])==_pp_prev_yr and int(r['ISO_Week'])==_pp_prev_wk
    # ‚îÄ‚îÄ Pre-compute data for all deep analytics tabs (outside tab blocks for scoping) ‚îÄ‚îÄ
    # Soju data
    _soju_rows = []
    for _, _r in _all_pp.iterrows():
        for _pn, _qty in extract_products(_r.get('PRODUCTS','')):
            if 'soju' in _pn.lower():
                _soju_rows.append({'Product': _pn.strip().title(),
                                   'Qty': _qty, 'Week': int(_r['ISO_Week']),
                                   'Year': int(_r['ISO_Year']), 'Sales': _r.get('SUBTOTAL',0)})
    _soju_df = pd.DataFrame(_soju_rows) if _soju_rows else pd.DataFrame()
    # Add composite key for safe year-boundary filtering
    if not _soju_df.empty:
        _soju_df['YW'] = _soju_df['Year'] * 100 + _soju_df['Week']
    _pp_cur_yw  = _pp_max_yr  * 100 + _pp_max_wk
    _pp_prev_yw = _pp_prev_yr * 100 + _pp_prev_wk

    # Cancelled data
    _can_df = _all_pp[_all_pp['STATE'].str.contains('Reject|Cancel|Failed', case=False, na=False)].copy()
    _can_prods = defaultdict(int)
    if not _can_df.empty:
        for _, _r in _can_df.iterrows():
            for _pn, _qty in extract_products(_r.get('PRODUCTS','')):
                _can_prods[standardize_product(_pn)] += _qty

    # Late night data
    _ln_df = _all_pp[(_all_pp['HOUR'] >= 23) | (_all_pp['HOUR'] <= 2)].copy()
    _total_all = len(_all_pp)

    # Pickup data
    if 'DELIVERY TYPE' in _all_pp.columns:
        _pick_df = _all_pp[_all_pp['DELIVERY TYPE'].str.lower().str.contains('pickup|pick_up|pick up', na=False)].copy()
    else:
        _pick_df = pd.DataFrame()
    _comp_all_pp = _all_pp[_all_pp['STATE'].isin(['Completed','Delivery Completed By Driver'])]
    _total_comp_pp = len(_comp_all_pp)

    # OOS data ‚Äî pre-build product weekly data from _pp_wk_prod (populated after tab5 product section runs)
    _oos_rows_precomp = []
    _oos_df = pd.DataFrame()  # will be populated after product analysis runs

    with _da_tab1:
        st.markdown("#### üç∂ Soju Product Analysis")
        if not _soju_df.empty:
            _soju_cur  = _soju_df[_soju_df['YW']==_pp_cur_yw]  if 'YW' in _soju_df.columns else _soju_df[(_soju_df['Week']==_pp_max_wk)&(_soju_df['Year']==_pp_max_yr)]
            _soju_prev = _soju_df[_soju_df['YW']==_pp_prev_yw] if 'YW' in _soju_df.columns else _soju_df[(_soju_df['Week']==_pp_prev_wk)&(_soju_df['Year']==_pp_prev_yr)]

            _sc1, _sc2, _sc3 = st.columns(3)
            _sc1.metric("Soju Units This Week", f"{int(_soju_cur['Qty'].sum()):,}")
            _sc2.metric("Soju Units Prev Week", f"{int(_soju_prev['Qty'].sum()):,}",
                        delta=f"{int(_soju_cur['Qty'].sum() - _soju_prev['Qty'].sum()):+}")
            _sc3.metric("Soju Revenue (TZS)", f"{_soju_cur['Sales'].sum()/1e3:.0f}K")

            # Weekly trend per soju variant
            _soju_wk = (_soju_df.groupby(['Year','Week','Product'])['Qty'].sum().reset_index())
            _soju_wk['Period'] = _soju_wk['Year'].astype(str) + "-W" + _soju_wk['Week'].astype(str).str.zfill(2)
            _soju_pivot = _soju_wk.pivot_table(index='Product', columns='Period', values='Qty', aggfunc='sum').fillna(0).astype(int)
            st.dataframe(_soju_pivot, use_container_width=True)

            _sfig, _sax = plt.subplots(figsize=(11,4))
            _soju_weekly_total = _soju_df.groupby('YW')['Qty'].sum().reset_index()
            _soju_weekly_total['Label'] = (_soju_weekly_total['YW'] // 100).astype(str) + "-W" + (_soju_weekly_total['YW'] % 100).astype(str).str.zfill(2)
            _sax.bar(_soju_weekly_total['Label'], _soju_weekly_total['Qty'], color='#9b59b6', alpha=0.8)
            _sax.set_xlabel("Year-Week"); _sax.set_ylabel("Units Sold")
            _sax.set_title("Total Soju Sales by Week"); _sax.grid(True, alpha=0.3, axis='y')
            plt.tight_layout(); st.pyplot(_sfig); plt.close()
        else:
            st.info("No soju products found in PRODUCTS column.")

    with _da_tab2:
        st.markdown("#### üì¶ Wholesale Orders Analysis")
        st.caption("High-value orders (‚â• 100,000 TZS subtotal) treated as potential wholesale")
        _WHOLESALE_MIN = 100_000
        _ws_df = _all_pp[_all_pp['SUBTOTAL'] >= _WHOLESALE_MIN].copy()
        if not _ws_df.empty:
            _ww1, _ww2, _ww3, _ww4 = st.columns(4)
            _ww1.metric("Wholesale Orders", f"{len(_ws_df):,}")
            _ww2.metric("Total Revenue", f"{_ws_df['SUBTOTAL'].sum()/1e6:.2f}M TZS")
            _ww3.metric("Avg Order Value", f"{_ws_df['SUBTOTAL'].mean()/1e3:.0f}K TZS")
            _ww4.metric("% of All Orders",
                        f"{len(_ws_df)/max(len(_all_pp),1)*100:.1f}%")

            _ws_weekly = (_ws_df.groupby(['ISO_Year','ISO_Week'])
                          .agg(Orders=('ID','count'), Revenue=('SUBTOTAL','sum'))
                          .reset_index().sort_values(['ISO_Year','ISO_Week']))
            _ws_weekly['Week_Label'] = "W" + _ws_weekly['ISO_Week'].astype(str)
            _wfig, _wax = plt.subplots(figsize=(11,4))
            _wax.bar(_ws_weekly['Week_Label'], _ws_weekly['Revenue']/1e3, color='#27ae60', alpha=0.8)
            _wax.set_ylabel("Revenue (K TZS)"); _wax.set_title("Wholesale Revenue by Week")
            _wax.grid(True, alpha=0.3, axis='y'); plt.tight_layout()
            st.pyplot(_wfig); plt.close()

            st.markdown("##### Top Wholesale Customers")
            _ws_cust = (_ws_df.groupby('CUSTOMER NAME')
                        .agg(Orders=('ID','count'), Revenue=('SUBTOTAL','sum'),
                             Avg_Order=('SUBTOTAL','mean'))
                        .reset_index().sort_values('Revenue', ascending=False))
            _ws_cust['Revenue'] = _ws_cust['Revenue'].apply(lambda x: f"{int(x):,}")
            _ws_cust['Avg_Order'] = _ws_cust['Avg_Order'].apply(lambda x: f"{int(x):,}")
            st.dataframe(_ws_cust.head(20), use_container_width=True)
        else:
            st.info("No wholesale-level orders found.")

    with _da_tab3:
        st.markdown("#### ‚ùå Cancelled & Rejected Orders")
        if not _can_df.empty:
            _ca1, _ca2, _ca3 = st.columns(3)
            _ca1.metric("Total Cancelled/Rejected", f"{len(_can_df):,}")
            _ca2.metric("This Week",
                        f"{len(_can_df[(_can_df['ISO_Week']==_pp_max_wk) & (_can_df['ISO_Year']==_pp_max_yr)]):,}")
            _ca3.metric("Cancellation Rate",
                        f"{len(_can_df)/max(len(_all_pp),1)*100:.1f}%")

            # State breakdown
            _can_state = _can_df['STATE'].value_counts().reset_index()
            _can_state.columns = ['Reason','Count']
            st.dataframe(_can_state, use_container_width=True)

            # Products in cancelled orders
            st.markdown("##### üè∑Ô∏è Products Most Appearing in Cancelled Orders")
            if _can_prods:
                _cp_df = pd.DataFrame(_can_prods.items(), columns=['Product','Qty in Cancellations'])
                _cp_df = _cp_df.sort_values('Qty in Cancellations', ascending=False)
                st.dataframe(_cp_df.head(15), use_container_width=True)

                _cpf, _cpa = plt.subplots(figsize=(10,4))
                _top_cp = _cp_df.head(10)
                _cpa.barh(_top_cp['Product'], _top_cp['Qty in Cancellations'], color='#e74c3c')
                _cpa.invert_yaxis(); _cpa.set_xlabel("Qty")
                _cpa.set_title("Top Products in Cancelled Orders"); plt.tight_layout()
                st.pyplot(_cpf); plt.close()

            # Weekly cancellation trend
            _can_wk = (_can_df.groupby('ISO_Week').size().reset_index(name='Cancellations'))
            _canwf, _canwa = plt.subplots(figsize=(10,3))
            _canwa.plot(_can_wk['ISO_Week'].astype(str), _can_wk['Cancellations'],
                        marker='o', color='#e74c3c', lw=2)
            _canwa.set_title("Cancellations by Week"); _canwa.grid(True, alpha=0.3)
            plt.tight_layout(); st.pyplot(_canwf); plt.close()
        else:
            st.info("No cancelled/rejected orders found.")

    with _da_tab4:
        st.markdown("#### üöó Pickup Orders Analysis")
        st.caption("STATE = 'Completed' orders analyzed for pickup vs delivery split")
        _comp_all = _comp_all_pp
        _total_comp = _total_comp_pp

        if not _pick_df.empty:
            _pi1, _pi2, _pi3, _pi4 = st.columns(4)
            _pi1.metric("Pickup Orders", f"{len(_pick_df):,}")
            _pi2.metric("Pickup Revenue", f"{_pick_df['SUBTOTAL'].sum()/1e6:.2f}M TZS")
            _pi3.metric("% of Completed Orders",
                        f"{len(_pick_df)/max(_total_comp,1)*100:.1f}%")
            _pi4.metric("Avg Pickup Value", f"{_pick_df['SUBTOTAL'].mean()/1e3:.0f}K TZS")

            _pick_wk = (_pick_df.groupby(['ISO_Year','ISO_Week'])
                        .agg(Orders=('ID','count'), Revenue=('SUBTOTAL','sum'))
                        .reset_index().sort_values(['ISO_Year','ISO_Week']))
            _pick_wk['Week_Label'] = "W" + _pick_wk['ISO_Week'].astype(str)
            _pifig, _piax = plt.subplots(figsize=(11,4))
            _piax.bar(_pick_wk['Week_Label'], _pick_wk['Orders'], color='#2980b9', alpha=0.8, label='Pickup Orders')
            _piax.set_title("Pickup Orders by Week"); _piax.grid(True, alpha=0.3, axis='y')
            _piax.legend(); plt.tight_layout(); st.pyplot(_pifig); plt.close()

            # Top customers for pickup
            st.markdown("##### üë§ Top Pickup Customers")
            _pick_cust = (_pick_df.groupby('CUSTOMER NAME')
                          .agg(Pickup_Orders=('ID','count'), Total_Spend=('SUBTOTAL','sum'),
                               Avg_Order=('SUBTOTAL','mean'))
                          .reset_index().sort_values('Pickup_Orders', ascending=False))
            _pick_cust['Total_Spend'] = _pick_cust['Total_Spend'].apply(lambda x: f"{int(x):,} TZS")
            _pick_cust['Avg_Order']   = _pick_cust['Avg_Order'].apply(lambda x: f"{int(x):,} TZS")
            _pick_cust.index = range(1, len(_pick_cust)+1)
            st.dataframe(_pick_cust.head(20), use_container_width=True)

            # Top customers for pickup orders
            st.markdown("##### üëë Top Customers ‚Äî Pickup Orders")
            _pick_top_cust = (_pick_df.groupby('CUSTOMER NAME')
                              .agg(Orders=('ID','count'), Total_Spend=('SUBTOTAL','sum'))
                              .reset_index().sort_values('Total_Spend', ascending=False).head(10))
            _pick_top_cust['Total_Spend'] = _pick_top_cust['Total_Spend'].apply(lambda x: f"{int(x):,} TZS")
            _pick_top_cust.index = range(1, len(_pick_top_cust)+1)
            st.dataframe(_pick_top_cust, use_container_width=True)
        else:
            # Fallback: show completed orders analysis
            st.info("DELIVERY TYPE column not found or no pickup entries ‚Äî showing all completed orders analysis.")
            if not _comp_all.empty:
                _co1, _co2, _co3 = st.columns(3)
                _co1.metric("Completed Orders", f"{_total_comp:,}")
                _co2.metric("Completed Revenue", f"{_comp_all['SUBTOTAL'].sum()/1e6:.2f}M TZS")
                _co3.metric("Avg Order Value", f"{_comp_all['SUBTOTAL'].mean()/1e3:.0f}K TZS")
                _comp_wk = (_comp_all.groupby('ISO_Week').agg(Orders=('ID','count')).reset_index())
                _cofig, _coax = plt.subplots(figsize=(11,4))
                _coax.bar(_comp_wk['ISO_Week'].astype(str), _comp_wk['Orders'], color='#27ae60', alpha=0.8)
                _coax.set_title("Completed Orders by Week"); _coax.grid(True, alpha=0.3, axis='y')
                plt.tight_layout(); st.pyplot(_cofig); plt.close()

    with _da_tab5:
        st.markdown("#### üåô Late Night Orders (23:00 ‚Äì 02:00)")
        if not _ln_df.empty:
            _ln1, _ln2, _ln3, _ln4 = st.columns(4)
            _ln1.metric("Late Night Orders", f"{len(_ln_df):,}")
            _ln2.metric("Revenue", f"{_ln_df['SUBTOTAL'].sum()/1e6:.2f}M TZS")
            _ln3.metric("% of Total Orders",
                        f"{len(_ln_df)/max(_total_all,1)*100:.1f}%")
            _ln4.metric("This Week",
                        f"{len(_ln_df[(_ln_df['ISO_Week']==_pp_max_wk) & (_ln_df['ISO_Year']==_pp_max_yr)]):,}")

            # Weekly trend
            _ln_wk = (_ln_df.groupby(['ISO_Year','ISO_Week'])
                      .agg(Orders=('ID','count'), Revenue=('SUBTOTAL','sum'))
                      .reset_index().sort_values(['ISO_Year','ISO_Week']))
            _ln_wk['Week_Label'] = "W" + _ln_wk['ISO_Week'].astype(str)
            _lnfig, _lnax = plt.subplots(figsize=(11,4))
            _lnax.plot(_ln_wk['Week_Label'], _ln_wk['Orders'],
                       marker='o', color='#8e44ad', lw=2, label='Late Night Orders')
            _lnax.fill_between(range(len(_ln_wk)), _ln_wk['Orders'],
                               alpha=0.15, color='#8e44ad')
            _lnax.set_title("Late Night Orders Trend"); _lnax.grid(True, alpha=0.3)
            _lnax.legend(); plt.xticks(rotation=30, ha='right'); plt.tight_layout()
            st.pyplot(_lnfig); plt.close()

            # Hour breakdown
            _ln_hr = _ln_df['HOUR'].value_counts().sort_index()
            _lnhf, _lnha = plt.subplots(figsize=(7,3))
            _lnha.bar(_ln_hr.index.astype(str), _ln_hr.values, color='#2c3e50', alpha=0.8)
            _lnha.set_xlabel("Hour"); _lnha.set_ylabel("Orders")
            _lnha.set_title("Distribution by Hour (23‚Äì02)"); plt.tight_layout()
            st.pyplot(_lnhf); plt.close()

            # Top products late night
            st.markdown("##### üõí Top Late Night Products")
            _ln_prods = defaultdict(int)
            for _, _r in _ln_df.iterrows():
                for _pn, _qty in extract_products(_r.get('PRODUCTS','')):
                    _ln_prods[standardize_product(_pn)] += _qty
            if _ln_prods:
                _lnp_df = pd.DataFrame(_ln_prods.items(), columns=['Product','Qty']).sort_values('Qty', ascending=False)
                st.dataframe(_lnp_df.head(10), use_container_width=True)
        else:
            st.info("No late night orders found.")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # OUT-OF-STOCK / MISSING PRODUCT ALERT
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    st.markdown("---")
    st.markdown('<div class="section-header">‚ö†Ô∏è Out-of-Stock & Availability Alerts</div>', unsafe_allow_html=True)
    if _pp_prod_totals:
        try:
            _wcp_len = len(_week_cols_pp)
        except NameError:
            _week_cols_pp = []
            _wcp_len = 0
    if _pp_prod_totals and _wcp_len >= 2:
        # Rebuild OOS using (ISO_Year, ISO_Week) from _pp_comp for accuracy
        _pp_cur_max_composite = _pp_max_yr * 100 + _pp_max_wk
        _pp_wk_prod_yr = defaultdict(lambda: defaultdict(int))
        for _, _oos_row in _pp_comp.iterrows():
            _yw = int(_oos_row['ISO_Year'])*100 + int(_oos_row['ISO_Week'])
            for _pn2, _qty2 in extract_products(_oos_row.get('PRODUCTS','')):
                _pp_wk_prod_yr[standardize_product(_pn2)][_yw] += _qty2

        _oos_rows = []
        for _prod, _wk_data in _pp_wk_prod_yr.items():
            _last_sold_yw = max((_yw for _yw, _q in _wk_data.items() if _q > 0), default=None)
            if _last_sold_yw and _last_sold_yw < _pp_cur_max_composite:
                _ls_yr, _ls_wk = _last_sold_yw // 100, _last_sold_yw % 100
                # How many calendar weeks missing
                _weeks_missing = ((_pp_max_yr - _ls_yr)*52 + (_pp_max_wk - _ls_wk))
                _hist_avg = sum(_wk_data.values()) / max(len(_wk_data),1)
                _oos_rows.append({'Product': _prod,
                                  'Last Sold': f"{_ls_yr}-W{_ls_wk:02d}",
                                  'Weeks Missing': _weeks_missing,
                                  'Hist. Weekly Avg Qty': round(_hist_avg,1)})
        if _oos_rows:
            _oos_df = pd.DataFrame(_oos_rows).sort_values('Weeks Missing', ascending=False)

            # Get avg order value from completed orders to estimate revenue loss
            _avg_order_val = _pp_comp['SUBTOTAL'].mean() if not _pp_comp.empty else 5000
            # Estimate revenue lost = hist_avg_qty * avg_items_per_order_revenue
            # Simpler: use avg price per product unit ~ avg_order_val / avg_items_per_order
            _avg_items_per_order = max(
                pd.Series([len(extract_products(r)) for r in _pp_comp['PRODUCTS'].dropna().head(200)]).mean(), 1
            )
            _price_per_unit = _avg_order_val / _avg_items_per_order

            _oos_df['Est. Weekly Revenue Lost (TZS)'] = (
                _oos_df['Hist. Weekly Avg Qty'] * _price_per_unit
            ).round(0).astype(int)

            # Sort by estimated revenue loss (highest first = most impactful)
            _oos_df = _oos_df.sort_values('Est. Weekly Revenue Lost (TZS)', ascending=False)

            _total_rev_lost = _oos_df['Est. Weekly Revenue Lost (TZS)'].sum()
            _top_oos = _oos_df.head(5)

            st.warning(
                f"‚ö†Ô∏è **{len(_oos_df)} products** not sold this week ‚Äî "
                f"estimated **{_total_rev_lost/1e3:.0f}K TZS** in weekly revenue at risk. "
                f"Sorted by highest revenue impact first."
            )

            # Highlight the top impactful missing products
            st.markdown("##### üî¥ Top Products Missing This Week (Highest Revenue Impact)")
            for _, _oos_r in _top_oos.iterrows():
                st.markdown(
                    f"- **{_oos_r['Product']}** ‚Äî last sold `{_oos_r['Last Sold']}` "
                    f"({_oos_r['Weeks Missing']} week(s) missing) | "
                    f"hist. avg **{_oos_r['Hist. Weekly Avg Qty']}** units/week | "
                    f"~**{_oos_r['Est. Weekly Revenue Lost (TZS)']:,} TZS** lost this week"
                )

            with st.expander("üìã View all missing products", expanded=False):
                _oos_display = _oos_df.copy()
                _oos_display['Est. Weekly Revenue Lost (TZS)'] = _oos_display['Est. Weekly Revenue Lost (TZS)'].apply(lambda x: f"{x:,}")
                st.dataframe(_oos_display, use_container_width=True)
        else:
            st.success("‚úÖ No products appear to be missing in the current week.")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # AI INSIGHT ‚Äî AUTO-RUNS (cached in session state)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    st.markdown("---")
    if not _pp_weekly.empty and _pp_prod_totals:
        _top5_str = pd.DataFrame(_pp_prod_totals.items(), columns=['Product','Qty'])\
                      .sort_values('Qty', ascending=False).head(10).to_string(index=False)

        # Soju summary for context
        _soju_ctx = ""
        try:
            if not _soju_df.empty:
                _s_cur  = _soju_df[_soju_df['YW']==_pp_cur_yw]
                _s_prev = _soju_df[_soju_df['YW']==_pp_prev_yw]
                _soju_ctx = (f"\nSOJU THIS WEEK (W{_pp_max_wk}/{_pp_max_yr}): {int(_s_cur['Qty'].sum())} units | "
                             f"PREV WEEK: {int(_s_prev['Qty'].sum())} units\n")
        except Exception:
            pass

        # Cancelled context
        _can_ctx = ""
        try:
            if not _can_df.empty:
                _top_can_prod = sorted(_can_prods.items(), key=lambda x: -x[1])[:3] if _can_prods else []
                _can_ctx = (f"\nCANCELLED ORDERS: {len(_can_df)} total ({len(_can_df)/max(len(_all_pp),1)*100:.1f}% rate)\n"
                            f"Top cancelled products: {', '.join([p for p,_ in _top_can_prod])}\n")
        except Exception:
            pass

        # Late night context
        _ln_ctx = ""
        try:
            if not _ln_df.empty:
                _ln_yw = _ln_df['ISO_Year'] * 100 + _ln_df['ISO_Week']
                _ln_this_wk = len(_ln_df[_ln_yw==_pp_cur_yw])
                _ln_ctx = (f"\nLATE NIGHT ORDERS: {len(_ln_df)} ({len(_ln_df)/max(_total_all,1)*100:.1f}% of total)\n"
                           f"This week (W{_pp_max_wk}/{_pp_max_yr}) late night: {_ln_this_wk}\n")
        except Exception:
            pass

        # OOS context
        _oos_ctx = ""
        try:
            if not _oos_df.empty:
                _top_oos_names = _oos_df.head(5)['Product'].tolist()
                _total_loss = _oos_df['Est. Weekly Revenue Lost (TZS)'].sum() if 'Est. Weekly Revenue Lost (TZS)' in _oos_df.columns else 0
                _oos_ctx = (f"\nPRODUCTS NOT SOLD THIS WEEK (potential OOS): {', '.join(_top_oos_names)}\n"
                            f"Estimated total revenue at risk from missing products: {_total_loss:,} TZS/week\n")
        except Exception:
            _oos_ctx = ""

        _pp_ctx = (f"PIKI PARTY STORE ANALYSIS ‚Äî Current Week: W{_pp_max_wk}\n"
                   f"Total completed orders: {len(_pp_comp):,}\n"
                   f"Total sales: {_pp_comp['SUBTOTAL'].sum()/1e6:.2f}M TZS\n"
                   f"Weeks available: {len(_pp_weekly)}\n\n"
                   f"TOP 10 PRODUCTS:\n{_top5_str}\n\n"
                   f"WEEKLY TREND (last 4 weeks):\n"
                   + _pp_weekly.tail(4)[['Week_Label','Total_Orders','Total_Sales']].to_string(index=False)
                   + _soju_ctx + _can_ctx + _ln_ctx + _oos_ctx)

        _pp_prompt = (
            "You are a senior BI analyst for Piki, a Tanzanian food delivery company.\n"
            "You are analysing the Piki Party Store ‚Äî a specialty party supply/catering store in Tanzania.\n\n"
            + _pp_ctx + "\n\n"
            "Provide a deep, comprehensive analysis:\n"
            "1. **Store Performance** ‚Äî Is Piki Party growing? Key trend observation with numbers.\n"
            "2. **Star Products & Out-of-Stock Alerts** ‚Äî Top sellers + flag any products missing this week that were selling before (possible stock-out or system issue).\n"
            "3. **Soju Performance** ‚Äî How are soju products selling? Any specific variant spiking or declining?\n"
            "4. **Cancellation Insights** ‚Äî Which products appear most in cancelled orders? What could be causing it?\n"
            "5. **Late Night Opportunity** ‚Äî Is the late night segment (23‚Äì02h) growing? How significant is it to the business?\n"
            "6. **Wholesale Signals** ‚Äî Any high-value orders suggesting bulk/wholesale demand? Opportunity?\n"
            "7. **Strategic Actions** ‚Äî 3 specific, prioritized recommendations to grow Piki Party revenue next week.\n\n"
            "Be specific, use real numbers from the data provided, write as a strategic advisor."
        )

        # Auto-run AI insight ‚Äî cached per data context, refresh button available
        _pp_ins_key = "pp_auto_insight"
        _pp_ctx_hash = str(hash(_pp_ctx[:300]))
        if _pp_ins_key not in st.session_state:
            st.session_state[_pp_ins_key]            = None
            st.session_state[_pp_ins_key + "_hash"]  = None
        if (st.session_state[_pp_ins_key] is None or
                st.session_state.get(_pp_ins_key + "_hash") != _pp_ctx_hash):
            with st.spinner("ü§ñ Generating Piki Party deep analysis‚Ä¶"):
                try:
                    st.session_state[_pp_ins_key]           = claude_insight(_pp_prompt, max_tokens=1200)
                    st.session_state[_pp_ins_key + "_hash"] = _pp_ctx_hash
                except Exception as _pp_err:
                    st.session_state[_pp_ins_key] = f"Error generating insight: {_pp_err}"
        if st.session_state[_pp_ins_key]:
            ai_block("piki_party", _pp_ctx, st.session_state[_pp_ins_key])
        _pp_ref_c1, _ = st.columns([2, 4])
        if _pp_ref_c1.button("‚Ü∫ Refresh AI Insight", key="pp_ins_refresh"):
            st.session_state[_pp_ins_key] = None
            st.rerun()
    else:
        st.info("Upload more data to generate AI insights for Piki Party.")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # DOWNLOADS
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    st.markdown("---")
    st.markdown('<div class="section-header">‚¨áÔ∏è Export Reports</div>', unsafe_allow_html=True)

    if _pp_prod_totals:
        _dl1, _dl2 = st.columns(2)

        _exp_buf1 = io.BytesIO()
        with pd.ExcelWriter(_exp_buf1, engine='xlsxwriter') as _ew:
            _pp_display.to_excel(_ew, sheet_name='Top Items', index=False)
            if not _cat_rank.empty:
                _cat_disp.to_excel(_ew, sheet_name='Category Ranking', index=False)
            _top_ord_view.to_excel(_ew, sheet_name='Top Orders by Value', index=False)

        _dl1.download_button("‚¨áÔ∏è Filtered Results (Excel)",
                             data=_exp_buf1.getvalue(),
                             file_name="Piki_Party_Filtered.xlsx",
                             mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

        _exp_buf2 = io.BytesIO()
        with pd.ExcelWriter(_exp_buf2, engine='xlsxwriter') as _ew2:
            if not _cat_rank.empty:
                _cat_disp.to_excel(_ew2, sheet_name='CATEGORY_RANKING', index=False)
            for _cname in (_cat_rank['Category'].unique() if not _cat_rank.empty else []):
                _csheet = _pp_matrix[_pp_matrix['Category']==_cname].sort_values('Total Qty', ascending=False)
                _csheet.to_excel(_ew2, sheet_name=str(_cname)[:31], index=False)

        _dl2.download_button("‚¨áÔ∏è Full Category Report (All Sheets)",
                             data=_exp_buf2.getvalue(),
                             file_name="Piki_Party_Full_Report.xlsx",
                             mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# FOOTER
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
st.divider()
st.caption("Piki Business Intelligence Dashboard ¬∑ Built with Streamlit & Claude AI ¬∑ Tanzania üáπüáø")
